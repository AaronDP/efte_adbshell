
sub .33 {                    # ( n -- ) print as nnn:nnn
   <hash
   bl hold
   3:hash
   ':' hold
   3:hash
   hash>
   verbosity @ if dup$ perr endif
   type$
}

sub accumulate { 10 * + }
sub emptyall  {
   depth$ times drop$
   depth times drop
}


sub testfilename { var$ new }
sub timestarted  { var new }
sub passed { var new }
sub failed { var new }

sub beforealltests {
   emptybuffer
   passed off
   failed off

   "selftest started" type$ cr
   microseconds timestarted !
   }


sub afteralltests {
   microseconds
   "selftest finished" type$ cr
   timestarted @ -  "Time elapsed: " type$ . "microseconds" type$ cr
    "failed/passed: " type$
    failed @ number$ type$ '/' emit passed @ number$ type$ cr
   }


# TODO: fix the multiple verbosity if ...
sub pass   {    # ( got wants testnum -- )
   >r
      dup2 equals
      depth depth$ accumulate 03 equals
      >r
      r@ and if "PASS" passed else "FAIL" failed endif 1 swap +!
      verbosity @ if "\n" perr dup$ perr endif type$
      r> minrot                                 # stacks: 0=err
      " test " verbosity @ if dup$ perr endif type$
   r> .33

   "wanted" type$  9 .r
   ", got"  type$  9 .r

   3 spaces
   if "stacks ok, " else "STACKS OFF," endif type$
   3 spaces

   testfilename fetch$ type$ cr
   emptyall
   filesave
}


sub initselftest {
   timestarted off
   256 bl repeat$ testfilename store$
}
