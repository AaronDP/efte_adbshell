#/home/l/efte/selftest/production
# -----------------------------------------------------------------------
# eFTE self test script
# This file has been automatically generated by the eFTE packaging tools.
# Manual changes to this file will very likely be lost, and may have an
# adverse effect on eFTE self testing capabilities.
# Copyright (c) 2008 eFTE Group
# -----------------------------------------------------------------------

sub dot33 {                    # ( n -- ) print as nnn:nnn
   lesshash                    
   bl hold
   3:hash
   58 hold
   3:hash
   hashmoretype
}

sub accumulate { 10 * + }
sub emptyall  {
   depth$ times drop$
   depth times drop
}


sub pass   {    # ( got wants testnum -- )  ( filename$ -- )
   tor
      dup2 equals
      depth depth$ accumulate 13 equals and
      if "PASS" else "FAIL" endif type$
   rfrom 
   " test " type$ dot33
   "wanted" type$ 9 dotr
   ", got"  type$ 9 dotr
   3 spaces type$ cr
   emptyall
}


# 1 - alwayspass.fte
sub test_1_1 { 222 222  1001 "alwayspass.fte" pass } # just two passing tests to test test and test that pass will pass
sub test_1_2 { 222 dup  1002 "alwayspass.fte" pass }
sub test_1_3 { test_1_1 test_1_2 }


# 2 - between.fte
sub test_2_1 { 10 8 12 between true  2001 "between.fte" pass }
sub test_2_2 { 8 8 12 between true  2002 "between.fte" pass }
sub test_2_3 { 12 8 12 between true  2003 "between.fte" pass }
 
sub test_2_4 { 5 8 12 between false  2004 "between.fte" pass }
sub test_2_5 { 15 8 12 between false  2005 "between.fte" pass }
 
sub test_2_6 { -5 -10 0 between true  2006 "between.fte" pass }
sub test_2_7 { -15 -10 0 between false  2007 "between.fte" pass }
sub test_2_8 { 10 -20 -10 between false  2008 "between.fte" pass }
 
sub test_2_9 { test_2_1 test_2_2 test_2_3 test_2_4 test_2_5 test_2_6 test_2_7 test_2_8 }


# 3 - bits.fte
sub test_3_1 { 2 invert -3  3001 "bits.fte" pass } # test invert
sub test_3_2 { -5 invert 4  3002 "bits.fte" pass }
 
sub test_3_3 { 0 not true  3003 "bits.fte" pass } # test not
sub test_3_4 { 1234 not false  3004 "bits.fte" pass }
sub test_3_5 { -321 not false  3005 "bits.fte" pass }
sub test_3_6 { true not false  3006 "bits.fte" pass }
sub test_3_7 { false not true  3007 "bits.fte" pass }
 
sub test_3_8 { test_3_1 test_3_2 test_3_3 test_3_4 test_3_5 test_3_6 test_3_7 }


# 4 - constants.fte
 # tests:
 # minus, plus,
 # primitives defined constants
 
sub test_4_1 { 20 15 - 5  4001 "constants.fte" pass }
sub test_4_2 { 20 15 + 35  4002 "constants.fte" pass }
sub test_4_3 { 0 false or 1 + true + 0  4003 "constants.fte" pass }
sub test_4_4 { 0 false + 1 - true * 1  4004 "constants.fte" pass }
sub test_4_5 { test_4_1 test_4_2 test_4_3 test_4_4 }


# 5 - exit.fte
sub test_5_1 { 333 exit lshift } # tests exit
sub test_5_2 { test_5_1 inc 334  5002 "exit.fte" pass }


# 6 - flowcontrol/doloop.fte
sub test_6_1 { 0 101 0 do i + loop 5050  6001 "flowcontrol/doloop.fte" pass }
sub test_6_2 { 0 200 100 do i + i 150 equals if leave endif inc loop lshift 12850  6002 "flowcontrol/doloop.fte" pass }
sub test_6_3 { 10 20 20 do inc inc inc loop dec 9  6003 "flowcontrol/doloop.fte" pass }
sub test_6_4 { 20 0 0 do dec dec dec loop inc 21  6004 "flowcontrol/doloop.fte" pass }
 
sub test_6_5 { 0 20 10 do i + 3 plusloop 58  6005 "flowcontrol/doloop.fte" pass }
sub test_6_6 { 0 -20 -10 do i + 3 minloop -58  6006 "flowcontrol/doloop.fte" pass }
sub test_6_7 { 0 -20 -10 do i + -3 plusloop -58  6007 "flowcontrol/doloop.fte" pass }
 
sub test_6_8 { 0 20 10 do i + 2 plusloop 70  6008 "flowcontrol/doloop.fte" pass }
sub test_6_9 { 0 -20 -10 do i + 2 minloop -70  6009 "flowcontrol/doloop.fte" pass }
sub test_6_10 { 0 -20 -10 do i + -2 plusloop -90  6010 "flowcontrol/doloop.fte" pass }
 
 
sub test_6_11 { test_6_1 test_6_2 test_6_3 test_6_4 test_6_5
 test_6_6 test_6_7 test_6_8 test_6_9 test_6_10 }
 


# 7 - flowcontrol/iftelsethen.fte
sub test_7_1 { 5 inc true if lshift inc else drop 0 endif lshift 26  7001 "flowcontrol/iftelsethen.fte" pass }
sub test_7_2 { 3 inc false if drop 0 else inc lshift endif inc 11  7002 "flowcontrol/iftelsethen.fte" pass }
sub test_7_3 { test_7_1 test_7_2 }


# 8 - flowcontrol/times.fte
sub test_8_1 { inc }
sub test_8_2 { 0 0 inc lshift lshift lshift times test_8_1 dec dec dec 5  8002 "flowcontrol/times.fte" pass }
sub test_8_3 { 5 0 times test_8_1 dec 4  8003 "flowcontrol/times.fte" pass }
sub test_8_4 { test_8_2 test_8_3 }


# 9 - flowcontrol/whileuntilagain.fte
sub test_9_1 { 50 6 inc begin lshift dec dup2 less if exit endif dec again drop 0 }
sub test_9_2 { test_9_1 + 133  9002 "flowcontrol/whileuntilagain.fte" pass }
sub test_9_3 { 200 3 lshift begin dec lshift dup2 more while dec lshift repeat + 714  9003 "flowcontrol/whileuntilagain.fte" pass }
sub test_9_4 { 100 2 inc begin lshift inc dup2 less until + 227  9004 "flowcontrol/whileuntilagain.fte" pass }
sub test_9_5 { test_9_2 test_9_3 test_9_4 }


# 10 - incdecnegate.fte
sub test_10_1 { 30 inc inc inc 33  10001 "incdecnegate.fte" pass }
sub test_10_2 { -2 inc inc inc inc inc 3  10002 "incdecnegate.fte" pass }
sub test_10_3 { 20 dec dec 18  10003 "incdecnegate.fte" pass }
sub test_10_4 { 1 dec dec dec dec -3  10004 "incdecnegate.fte" pass }
sub test_10_5 { 12 negate -12  10005 "incdecnegate.fte" pass }
sub test_10_6 { -15 negate 15  10006 "incdecnegate.fte" pass }
sub test_10_7 { -8 abs 8  10007 "incdecnegate.fte" pass }
sub test_10_8 { 5 abs 5  10008 "incdecnegate.fte" pass }
sub test_10_9 { test_10_1 test_10_2 test_10_3 test_10_4 test_10_5 test_10_6 test_10_7 test_10_8 }
 


# 11 - lshift.fte
sub test_11_1 { 4 lshift 8  11001 "lshift.fte" pass } # test lshift
sub test_11_2 { -4 lshift -8  11002 "lshift.fte" pass }
sub test_11_3 { test_11_1 test_11_2 }


# 12 - memory.fte
sub test_12_1 { here 5 allot here - -5  12001 "memory.fte" pass }
sub test_12_2 { here dup dup 100 + store here swap  12002 "memory.fte" pass }
sub test_12_3 { here dup 6 1 do i over store inc loop drop
 6 1 do 1 allot loop
 0 6 1 do tor count rfrom + loop nip
 15  12003 "memory.fte" pass }
 
sub test_12_4 { test_12_1 test_12_2 test_12_3 }


# 13 - minmax.fte
sub test_13_1 { 2 5 min 2  13001 "minmax.fte" pass }
sub test_13_2 { 2 5 max 5  13002 "minmax.fte" pass }
sub test_13_3 { -3 -7 min -7  13003 "minmax.fte" pass }
sub test_13_4 { -3 -7 max -3  13004 "minmax.fte" pass }
 
sub test_13_5 { -2 5 min -2  13005 "minmax.fte" pass }
sub test_13_6 { -2 5 max 5  13006 "minmax.fte" pass }
sub test_13_7 { 3 -7 min -7  13007 "minmax.fte" pass }
sub test_13_8 { 3 -7 max 3  13008 "minmax.fte" pass }
 
sub test_13_9 { test_13_1 test_13_2 test_13_3 test_13_4 test_13_5 test_13_6 test_13_7 test_13_8 }


# 14 - mod.fte
sub test_14_1 { 20 5 mod 0  14001 "mod.fte" pass }
sub test_14_2 { 15 4 mod 3  14002 "mod.fte" pass }
sub test_14_3 { -18 4 mod -2  14003 "mod.fte" pass }
sub test_14_4 { -24 -7 mod -3  14004 "mod.fte" pass }
sub test_14_5 { test_14_1 test_14_2 test_14_3 test_14_4 }
 


# 15 - niptuckpluck.fte
sub test_15_1 { 4 6 8 drop accumulate 64  15001 "niptuckpluck.fte" pass } # test drop
sub test_15_2 { 3 6 swap accumulate 36  15002 "niptuckpluck.fte" pass } # test swap
sub test_15_3 { 2 5 over 2:accumulate 252  15003 "niptuckpluck.fte" pass } # test over
sub test_15_4 { 1 2 3 nip accumulate 31  15004 "niptuckpluck.fte" pass } # test nip
sub test_15_5 { 4 5 6 minrot 2:accumulate 546  15005 "niptuckpluck.fte" pass } # test minrot
sub test_15_6 { 7 8 9 tuck 3:accumulate 9897  15006 "niptuckpluck.fte" pass } # test tuck
sub test_15_7 { 2 4 6 pluck 3:accumulate 2642  15007 "niptuckpluck.fte" pass } # test pluck
sub test_15_8 { test_15_1 test_15_2 test_15_3 test_15_4 test_15_5 test_15_6 test_15_7 }


# 16 - plus.fte
sub test_16_1 { 3 5 + 8  16001 "plus.fte" pass }
sub test_16_2 { -2 9 + 7  16002 "plus.fte" pass }
sub test_16_3 { 6 -8 + -2  16003 "plus.fte" pass }
sub test_16_4 { -11 -7 + -18  16004 "plus.fte" pass }
sub test_16_5 { test_16_1 test_16_2 test_16_3 test_16_4 }


# 17 - qdup.fte
sub test_17_1 { 2 0 qdup swap qdup 10 * + 10 * + 220  17001 "qdup.fte" pass } # tests qdup


# 18 - rfromtor.fte
sub test_18_1 { 5 7 9 tor swap rfrom 2:accumulate 957  18001 "rfromtor.fte" pass }
sub test_18_2 { 2 3 tor 5 rfetch swap rfrom 3:accumulate 3532  18002 "rfromtor.fte" pass }
sub test_18_3 { test_18_1 test_18_2 }


# 19 - rshift.fte
sub test_19_1 { 10 dup rshift dup +  19001 "rshift.fte" pass } # test rshift
sub test_19_2 { -10 dup rshift dup +  19002 "rshift.fte" pass }
sub test_19_3 { test_19_1 test_19_2 }


# 20 - strings/strings1.fte
 
 # depth$ - string pushing - len$ - asc/char$ - split$
 
 # see whether depth$ reports correctly
sub test_20_1 { depth$ "ABCD 12345" depth$ drop$ accumulate 10  20001 "strings/strings1.fte" pass }
 
 # test push with different string lengths
sub test_20_2 { "ABCD" "12345" "x" "ab" "" depth$ dup times drop$ 5  20002 "strings/strings1.fte" pass }
 
 # len$ fails
sub test_20_3 { "" ?len$ 0  20003 "strings/strings1.fte" pass }
 
 # test len$
sub test_20_4 { "12345" len$ "abc" len$ "" ?len$ "a" len$ 4:accumulate 1035  20004 "strings/strings1.fte" pass }
 
 # test asc / char$
sub test_20_5 { "1" asc inc char$ 3 asc + char$ 2 asc + '7'  20005 "strings/strings1.fte" pass }
 
 # split$ tests
sub test_20_6 { "" asc 0  20006 "strings/strings1.fte" pass }
sub test_20_7 { "123456" 0 split$ len$ len$ accumulate 6  20007 "strings/strings1.fte" pass }
sub test_20_8 { "ABCDEFGH" -100 split$ len$ len$ accumulate 8  20008 "strings/strings1.fte" pass }
sub test_20_9 { "1234" 100 split$ len$ len$ accumulate 40  20009 "strings/strings1.fte" pass }
sub test_20_10 { "12345678 " 1 split$ asc drop$ '1'  20010 "strings/strings1.fte" pass }
sub test_20_11 { "45678" 2 split$ asc drop$ '4'  20011 "strings/strings1.fte" pass }
sub test_20_12 { "abcdef" 3 split$ asc drop$ 'a'  20012 "strings/strings1.fte" pass }
sub test_20_13 { "12345678" 0 split$ drop$ len$ '1'  20013 "strings/strings1.fte" pass }
sub test_20_14 { "12345678" 1 split$ drop$ asc '2'  20014 "strings/strings1.fte" pass }
sub test_20_15 { "45678" 2 split$ drop$ asc '6'  20015 "strings/strings1.fte" pass }
sub test_20_16 { "abcdef" 3 split$ drop$ asc 'd'  20016 "strings/strings1.fte" pass }
 
 
sub test_20_17 { test_20_1 test_20_2 test_20_3 test_20_4 test_20_5 test_20_6 test_20_7 test_20_8
 test_20_9 test_20_10 test_20_11 test_20_12 test_20_13 test_20_14 test_20_15 test_20_16}
 


# 21 - strings/strings2.fte
 # equal$ mid$
 
 
 # equal$ ( needed for next tests )
sub test_21_1 { "a" "a" equals$ true  21001 "strings/strings2.fte" pass }
sub test_21_2 { "B" 'A' inc char$ equals$ true  21002 "strings/strings2.fte" pass }
sub test_21_3 { "A" 'B' inc char$ equals$ false  21003 "strings/strings2.fte" pass }
 
 # mid$
 # interesting case. return "ABC" or "ABCDE"? trying both
sub test_21_4 { "ABCDEFG" -2 5 mid$ "ABC" equals$ true  21004 "strings/strings2.fte" pass }
sub test_21_5 { "ABCDEFG" -2 5 mid$ "ABCDE" equals$ true  21005 "strings/strings2.fte" pass }
 
sub test_21_6 { "abcdefgh" 0 2 mid$ "ab" equals$ true  21006 "strings/strings2.fte" pass }
sub test_21_7 { "123456" 1 3 mid$ "234" equals$ true  21007 "strings/strings2.fte" pass }
sub test_21_8 { "ABCDEF" 4 6 mid$ "EF" equals$ true  21008 "strings/strings2.fte" pass }
 
 #{ "abcde" 10 10 mid$ "" equals$ true  21008 "strings/strings2.fte" pass }
sub test_21_9 { false false not  21009 "strings/strings2.fte" pass } # just an attention drawer for the line above - terminates efte.
 
 # negative len not tested yet
 
 
sub test_21_10 { test_21_1 test_21_2 test_21_3 test_21_4 test_21_5 test_21_6 test_21_7 test_21_8 test_21_9 }
 
 
 


# 22 - strings/strings3.fte
 # split$ merge$
 
sub test_22_1 { "abcdefgh" 3 split$ "abc" equals$ "defgh" equals$ and true  22001 "strings/strings3.fte" pass }
sub test_22_2 { "1234" 0 split$ "" equals$ "1234" equals$ and true  22002 "strings/strings3.fte" pass }
sub test_22_3 { "ABCDE" 10 split$ "ABCDE" equals$ "" equals$ and true  22003 "strings/strings3.fte" pass }
sub test_22_4 { "" 0 split$ "" equals$ "" equals$ and true  22004 "strings/strings3.fte" pass }
sub test_22_5 { "" 5 split$ "" equals$ "" equals$ and true  22005 "strings/strings3.fte" pass }
sub test_22_6 { "" -2 split$ "" equals$ "" equals$ and true  22006 "strings/strings3.fte" pass }
 
sub test_22_7 { "123" "abcd" merge$ "abcd123" equals$ true  22007 "strings/strings3.fte" pass }
sub test_22_8 { "456" "" merge$ "456" equals$ true  22008 "strings/strings3.fte" pass }
sub test_22_9 { "" "efg" merge$ "efg" equals$ true  22009 "strings/strings3.fte" pass }
 
sub test_22_10 { test_22_1 test_22_2 test_22_3 test_22_4 test_22_5 test_22_6 test_22_7 test_22_8 test_22_9 }
 


# 23 - zzz_final.fte
sub test_23_1 { depth depth$ or 0  23001 "zzz_final.fte" pass }


sub selftest {
   "selftest started" type$ cr
    test_1_3 test_2_9 test_3_8 test_4_5 test_5_2 test_6_11 test_7_3 test_8_4
    test_9_5 test_10_9 test_11_3 test_12_4 test_13_9 test_14_5 test_15_8 test_16_5
    test_17_1 test_18_3 test_19_3 test_20_17 test_21_10 test_22_10 test_23_1
   "selftest finished" type$ cr
}
