# -----------------------------------------------------------------------
# eFTE self test script
# This file has been automatically generated by the eFTE packaging tools.
# Manual changes to this file will very likely be lost, and may have an
# adverse effect on eFTE self testing capabilities.
# Copyright (c) 2008 eFTE Group
# -----------------------------------------------------------------------

sub basefetch { push 10 }
sub digit     { push '0' plus dup push '9' more if push 39 plus endif } # ( u -- asc )
sub slashmod  { dup2 div dup tor mul minus abs rfrom }                  # ( n1 n2 -- r q )
sub hold      { minrot inc }                                            # ( ??? n1 n2 asc -- ??? asc n2 n3 )
sub sign      { over negative if push '-' minrot inc endif }            # ( ??? n1 n2 -- ??? asc n1 n3 }
sub hash      { tor basefetch slashmod tor digit rfrom rfrom inc }      # ( ??? n1 n2  -- ??? asc n3 n4 )
sub hashs     { begin hash over not until nip }                         # ( ??? n1 n2 -- ??? n3 )
sub emits     { times emit }                                            # ( ??? n -- )
sub brudotbr  { zero hashs }                                            # ( u -- ??? n )
sub udot      { brudotbr emits space }                                  # ( u -- )
sub dotstar   { push '*' emit }                                         # ( -- )

sub dotpadded { dup2 more if                                            # doesn't fit:
                   times dotstar                                        #    fill with stars
                   times drop                                           #    remove digits
                else                                                    # fits:
                   over minus spaces                                    #    pad with spaces
                   emits                                                #    emit digits
                endif }                                                 # ( ??? n1 n2 -- )

sub udotr     { tor brudotbr rfrom dotpadded }                          # ( u n -- )


sub pass   {
   tor dup2 equals if            insertstring "PASS"
   else                          insertstring "FAIL"
   endif 
   rfrom insertstring " test"    push 6 udotr
   insertstring " wants "    push 6 udotr
   insertstring ", gets "    push 6 udotr
   cr
}

sub accumulate { push 10 mul plus }

# components/alwayspass
sub test_1_1 { push 222 222 push 1001 pass } # just two passing tests to test test and test that pass will pass
sub test_1_2 { push 222 dup push 1002 pass }
sub test_1_3 { test_1_1 test_1_2 }


# components/between
sub test_2_1 { push 10 8 12 between true push 2001 pass }
sub test_2_2 { push 8 8 12 between true push 2002 pass }
sub test_2_3 { push 12 8 12 between true push 2003 pass }
 
sub test_2_4 { push 5 8 12 between false push 2004 pass }
sub test_2_5 { push 15 8 12 between false push 2005 pass }
 
sub test_2_6 { push -5 -10 0 between true push 2006 pass }
sub test_2_7 { push -15 -10 0 between false push 2007 pass }
sub test_2_8 { push 10 -20 -10 between false push 2008 pass }
 
sub test_2_9 { test_2_1 test_2_2 test_2_3 test_2_4 test_2_5 test_2_6 test_2_7 test_2_8 }


# components/bits
sub test_3_1 { push 2 invert push -3 push 3001 pass } # test invert
sub test_3_2 { push -5 invert push 4 push 3002 pass }
 
sub test_3_3 { push 0 not true push 3003 pass } # test not
sub test_3_4 { push 1234 not false push 3004 pass }
sub test_3_5 { push -321 not false push 3005 pass }
sub test_3_6 { push true not false push 3006 pass }
sub test_3_7 { push false not true push 3007 pass }
 
sub test_3_8 { test_3_1 test_3_2 test_3_3 test_3_4 test_3_5 test_3_6 test_3_7 }


# components/constants
 # tests:
 # minus, plus,
 # primitives defined constants
 
sub test_4_1 { push 20 15 minus push 5 push 4001 pass }
sub test_4_2 { push 20 15 plus push 35 push 4002 pass }
sub test_4_3 { zero false or one plus true plus push 0 push 4003 pass }
sub test_4_4 { zero false plus one minus true mul push 1 push 4004 pass }
sub test_4_5 { test_4_1 test_4_2 test_4_3 test_4_4 }


# components/doloop
sub test_5_1 { push 0 101 0 do i plus loop push 5050 push 5001 pass }
sub test_5_2 { push 0 200 100 do i plus i push 150 equals if leave endif inc loop lshift push 12850 push 5002 pass }
sub test_5_3 { test_5_1 test_5_2 }


# components/exit
sub test_6_1 { push 333 exit lshift } # tests exit
sub test_6_2 { test_6_1 inc push 334 push 6002 pass }


# components/iftelsethen
sub test_7_1 { push 5 inc true if lshift inc else drop zero endif lshift push 26 push 7001 pass }
sub test_7_2 { push 3 inc false if drop zero else inc lshift endif inc push 11 push 7002 pass }
sub test_7_3 { test_7_1 test_7_2 }


# components/incdecnegate
sub test_8_1 { push 30 inc inc inc push 33 push 8001 pass }
sub test_8_2 { push -2 inc inc inc inc inc push 3 push 8002 pass }
sub test_8_3 { push 20 dec dec push 18 push 8003 pass }
sub test_8_4 { push 1 dec dec dec dec push -3 push 8004 pass }
sub test_8_5 { push 12 negate push -12 push 8005 pass }
sub test_8_6 { push -15 negate push 15 push 8006 pass }
sub test_8_7 { push -8 abs push 8 push 8007 pass }
sub test_8_8 { push 5 abs push 5 push 8008 pass }
sub test_8_9 { test_8_1 test_8_2 test_8_3 test_8_4 test_8_5 test_8_6 test_8_7 test_8_8 }
 


# components/lshift
sub test_9_1 { push 4 lshift push 8 push 9001 pass } # test lshift
sub test_9_2 { push -4 lshift push -8 push 9002 pass }
sub test_9_3 { test_9_1 test_9_2 }


# components/minmax
sub test_10_1 { push 2 5 min push 2 push 10001 pass }
sub test_10_2 { push 2 5 max push 5 push 10002 pass }
sub test_10_3 { push -3 -7 min push -7 push 10003 pass }
sub test_10_4 { push -3 -7 max push -3 push 10004 pass }
 
sub test_10_5 { push -2 5 min push -2 push 10005 pass }
sub test_10_6 { push -2 5 max push 5 push 10006 pass }
sub test_10_7 { push 3 -7 min push -7 push 10007 pass }
sub test_10_8 { push 3 -7 max push 3 push 10008 pass }
 
sub test_10_9 { test_10_1 test_10_2 test_10_3 test_10_4 test_10_5 test_10_6 test_10_7 test_10_8 }


# components/mod
sub test_11_1 { push 20 5 mod zero push 11001 pass }
sub test_11_2 { push 15 4 mod push 3 push 11002 pass }
sub test_11_3 { push -18 4 mod push -2 push 11003 pass }
sub test_11_4 { push -24 -7 mod push -3 push 11004 pass }
sub test_11_5 { test_11_1 test_11_2 test_11_3 test_11_4 }
 


# components/niptuckpluck
sub test_12_1 { push 4 6 8 drop accumulate push 64 push 12001 pass } # test drop
sub test_12_2 { push 3 6 swap accumulate push 36 push 12002 pass } # test swap
sub test_12_3 { push 2 5 over 2:accumulate push 252 push 12003 pass } # test over
sub test_12_4 { push 1 2 3 nip accumulate push 31 push 12004 pass } # test nip
sub test_12_5 { push 4 5 6 minrot 2:accumulate push 546 push 12005 pass } # test minrot
sub test_12_6 { push 7 8 9 tuck 3:accumulate push 9897 push 12006 pass } # test tuck
sub test_12_7 { push 2 4 6 pluck 3:accumulate push 2642 push 12007 pass } # test pluck
sub test_12_8 { test_12_1 test_12_2 test_12_3 test_12_4 test_12_5 test_12_6 test_12_7 }


# components/plus
sub test_13_1 { push 3 5 plus push 8 push 13001 pass }
sub test_13_2 { push -2 9 plus push 7 push 13002 pass }
sub test_13_3 { push 6 -8 plus push -2 push 13003 pass }
sub test_13_4 { push -11 -7 plus push -18 push 13004 pass }
 
sub test_13_5 { push 777 # stack "marker"
 test_13_1 # run tests
 test_13_2
 test_13_3
 test_13_4
 push 777 push 13005 pass } #is stack balanced?


# components/qdup
sub test_14_1 { push 2 0 qdup swap qdup push 10 mul plus push 10 mul plus push 220 push 14001 pass } # tests qdup


# components/rfromtor
sub test_15_1 { push 5 7 9 tor swap rfrom 2:accumulate push 957 push 15001 pass }
sub test_15_2 { push 2 3 tor push 5 rfetch swap rfrom 3:accumulate push 3532 push 15002 pass }
sub test_15_3 { test_15_1 test_15_2 }


# components/rshift
sub test_16_1 { push 10 dup rshift dup plus push 16001 pass } # test rshift
sub test_16_2 { push -10 dup rshift dup plus push 16002 pass }
sub test_16_3 { test_16_1 test_16_2 }


# components/stringpush
sub test_17_1 { depth$ push$ "ABCD 12345" depth$ accumulate push 10 push 17001 pass }


# components/times
sub test_18_1 { inc }
sub test_18_2 { zero zero inc lshift lshift lshift times test_18_1 dec dec dec push 5 push 18002 pass }
sub test_18_3 { test_18_2 }


# components/whileuntilagain
sub test_19_1 { push 50 6 inc begin lshift dec dup2 less if exit endif dec again drop zero }
sub test_19_2 { test_19_1 plus push 133 push 19002 pass }
sub test_19_3 { push 200 3 lshift begin dec lshift dup2 more while dec lshift repeat plus push 714 push 19003 pass }
sub test_19_4 { push 100 2 inc begin lshift inc dup2 less until plus push 227 push 19004 pass }
sub test_19_5 { test_19_2 test_19_3 test_19_4 }


sub selftest {
   message "selftest finished"
   push 12345678      # stack 'marker'
    test_1_3 test_2_9 test_3_8 test_4_5 test_5_3 test_6_2 test_7_3 test_8_9
    test_9_3 test_10_9 test_11_5 test_12_8 test_13_5 test_14_1 test_15_3 test_16_3
    test_17_1 test_18_3 test_19_5
   push 12345678 99999 pass # all tests balanced?
   message "selftest finished"
}
