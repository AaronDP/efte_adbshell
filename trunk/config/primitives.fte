# primitives.fte
#
# Copyright (c) 2008, eFTE SF Group (see AUTHORS file)
#
# You may distribute under the terms of either the GNU General Public
# License or the Artistic License, as specified in the README file.
#
# some tools and enhancements for macros.
# this are currently used for testing and toying
# with macros, as result many of the current macros
# assume these to be present, as factored out functionality.
#

# can't use this chars in names (yet):   = , # :

# -- constants --
sub false     { 0 }
sub true      { -1 }                            # "true" represented as all bits sets
sub cell      { 1 }                             # memory increments per integer
sub cell+     { 1 + }
sub cell-     { 1 - }
sub cells     { }


# -- stack --
sub qdup      { dup if dup endif }              # duplicate top of stack if <> 0
sub nip       { swap drop }                     # drop second of stack
sub tuck      { swap over }                     # copy top of stack below second of stack
sub pluck     { >r over r> swap }               # copy 3rd item to top
sub minrot    { 2:rot }                         # rotate top item below second item
sub dup2      { 2:over }                        # duplicate top two items
sub drop2     { 2:drop }                        # drop top two items
sub swap2     { rot >r rot r> }                 # swap top two pairs of items


# -- arithmetic, bool, bits, comparison  --
sub inc       { 1 + }                           # increment top of stack by one
sub dec       { 1 - }                           # decrement top of stack by one
sub invert    { -1 xor }                        # complement all bits
sub negate    { invert inc }                    # change sign
sub not       { 0 equals }                      # logical inversion: 0->true,  x->0
sub lshift    { 1 shift }                       # bit shift left once
sub rshift    { -1 shift }                      # bit shift right once
sub <<        { shift }                         
sub >>        { negate shift }
sub success   { flag }                          # push command return code
sub failure   { flag not }                      # push inverted command return code
sub >         { swap < }                        # true if nos > tos
sub between   { rot tuck < minrot > or not }
sub negative  { 0 < }                           # < zero?
sub abs       { dup negative if negate endif }  # remove sign
sub min       { dup2 > if swap endif drop }
sub max       { dup2 < if swap endif drop }
sub mod       { dup2 / * - }                    # modulo (remainder) function
sub gcd       { begin tuck mod qdup not until } # greatest common denominator
sub sqrt      { 0 tuck do inc dup lshift inc +loop }
sub range     { over + swap }                   # start n -> limit start conversion for DO LOOP

# --- character test
sub capital   { 'A' 'Z' between }
sub lowercase { 'a' 'z' between }
sub capitalize { dup lowercase if 32 - endif }

# -- cursor --
sub cursorhome { movelinestart }
sub cursorend  { movelineend }






# need:
#  test block marked?
#  0 split$ no fail


# =============================================================================
#    memory
# =============================================================================

sub off       { false swap ! }                  # ( a -- )   sets contents of a to false
sub on        { true swap ! }                   # ( a -- )   sets contents of a to true
sub count     { inc dup dec @ }
sub +!        { dup >r @ + r> ! }               # ( x a -- )  adds x to contents of address a
sub comma     { here cell allot ! }             # ( x -- )    allocate 1 location, initialized to x
                                                # can then use vars like:      sub bar { var new }
                                                #                foo @   bar !

sub exchange  { dup @ >r ! r> }                 # ( x1 a -- x2 )
sub link      { here swap exchange comma }      # ( a -- )
sub free      { memend here - }



sub var       { here dup cell allot }           # for the new construct:       sub foo { var new }




# =============================================================================
#    strings
# =============================================================================

# thinking of
#  or$:  copy chars from string two into spaces of string 1
#  and$: replace chars in string one against space, if string2 has space on that pos
# example:
# string1:  "xxx    xxx"
# string2:  "1 345678 0"
# or$:      "xxx4567xxx"
# and$:     "x x    x x"
# xor$"     " x 4567 x "


sub nip$      { swap$ drop$ }
sub tuck$     { swap$ over$ }
sub minrot$   { 2:rot$  }
sub dup2$     { 2:over$ }
sub drop2$    { 2:drop$ }
sub equals$   { compare$ not }
sub append$   { merge$ }                        # merge$ is a rename candidate
sub prepend$  { swap$ merge$ }                  # merge$ is a rename candidate


sub slice     { 1 split$ asc }                  # ( -- asc ) cut first char off string and return as ascii
sub splice    { char$ prepend$ }                # ( asc -- ) prepend char to string
sub ascn      { dup$ 1 mid$ asc }               # ( n -- c ) get ascii of nth char in top string


# -- i/o --
sub key       { getchar }                       # wait for key, place its ascii on stack
sub read      { curchar$ }                      # read char under cursor
sub emit      { char$ insertstring }
sub type1     { count emit }
sub type      { times type1 drop }              # string output
sub type$     { insertstring }
sub bl        { 32 }
sub space     { 32 emit }                       # print a space character
sub spaces    { times space }
sub cr        { cursorend linenew cursorhome }  # carriage return



sub left$     {                                 # ( n -- )
   dup negative if                              # negative n: strip first n chars
      negate dup$ len$ over -
   else                                         # positive n: keep first n chars
      0 swap
   endif
   mid$ }

sub right$    {                                 # ( n -- )
  dup negative if                               # negative n: strip last n chars
     0 dup$ len$ rot +
  else                                          # positive n: keep last n chars
     dup negate swap
  endif
  mid$ }


sub search$   {                                 # ( n1 -- n2 )
  true swap                                     # search though n1 string stack items,
  0 do                                          # matching against top string. returns
    i inc pick$                                 # item number of matching string as n2,
    over$ equals$                               # or -1
    if drop i leave endif
  loop
  drop$
}


sub embed$ {                                    # ( asc n -- ) store char at pos n of topmost string, overwriting
   dup dup$ left$                               # cut and keep chars left of write pos
   invert swap$ left$                           # cut and keep chars right of write pos (tricky)
   splice append$                               # recombine, with char between
}

sub capitalize$ {                               # ( -- )  capitalize all chars of top string
   dup$ len$ 0 do                                    # loop though all chars:
      i ascn dup lowercase if
         capitalize
         dup i embed$                           #   replace char in string
      endif drop
   loop }


sub repeat$ {                                   # ( u c -- ) create a string of u times char
   swap ""
   qdup if
      over char$
      dup 1 do
         append$ dup$
      i +loop
      swap$ dup$ len$ - left$ append$
   endif
   drop
}


sub spaces$ { bl repeat$ }                      # ( u -- ) create a string of u spaces


sub minleading$ {                               # ( -- ) remove leading spaces
   dup$ len$                                         # assume removing whole string
   dup 0 do                                     # loop through string,
      i ascn bl equals not                      # looking for non-space
      if drop i leave endif                     # found, return index to space
   loop
   negate left$                                 # remove leading spaces
}


sub mintrailing$ {                              # ( -- ) remove trailing spaces
   dup$ len$
   dup 0 do                                     # loop through sting chars
      dec dup ascn                              # select chars, starting with last
      bl equals not if                          # until char not space
         inc leave
      endif
   loop
   left$ }                                      # keep the non-space chars


# test with empty string, and spaces only string
sub trim$ {                                     # ( -- ) remove leading and trailing spaces
   minleading$
   mintrailing$ }          



sub scan$ {                                     # ( asc -- -1 | u )  search for asc in string.
   -1
   dup$ len$ 0 do
      over i ascn equals
      if drop i leave endif
   loop
   drop$ nip }




sub brmovebr$  {                                # ( a n -- )  copy n chars of tos$ to a
   swap dup2 ! inc
   swap range do
      slice i !
   loop drop$ }

sub move$    { dup$ len$  brmovebr$ }           # ( a -- ) transfers string on string stack to a

sub store$   {                                  # ( a -- ) transfers string on string stack to a
   count                                        # structure size
   2 cells -                                    # subtract space for structure size and leading string count
   dup$ len$ min                                # move smaller of this max and string size number of chars.
   brmovebr$ }

sub fetch$    {                                 # ( a -- ) transfers the string at a to string stack.
   cell +                                       # skip first cell (containing amount of allocated space to string var)
   ""
   count 0 do                                   # for all chars in string do ...
      count char$ append$                       # get char and add to string
   loop drop }

sub var$ { here dup dup$ len$ inc dup inc comma allot } # string var description.
# (varsize) (strlen) (char) (char) (char) ...


#sub var$ {
#   here              diag diag$  "A " 2 print
#   dup$ len$ inc     diag diag$  "B " 2 print
#   dup inc comma     diag diag$  "C " 2 print
#   allot             diag diag$  "D " 2 print
#   dup store$        diag diag$  "E " 2 print
#   }



# --- debugging

sub println { print "\n" print }
sub pout    { 1 print }
sub perr    { 2 print }
sub poutln  { 1 println }
sub perrln  { 2 println }




# --- the number conversion words below respect base, and convert accordingly ---
# we need to init base somewhere - vars are initialized to zero, which is not a good number base.
# using number output without setting base first will result in division by zero
# time for checking out the OnStart: event, which should be ideally suited for one-time init.
sub base      { var new }                        # number base for pic'd num conversion
sub decimal   { 10 base ! }
sub hex       { 16 base ! }
sub octal     {  8 base ! }
sub binary    {  2 base ! }


# --- pictured number conversion ---
sub digit     { '0' + dup '9' > if 7 + endif }  # ( u -- asc )
sub /mod      { dup2 / dup >r * - abs r> }      # ( n1 n2 -- r q )
sub <hash     { "" } 	  		                # ( n -- n ) start pictured num conversion
sub hold      { char$ prepend$ }                # ( n asc -- n )
sub hash      { base @ /mod swap digit hold }   # ( n1 -- n2 )
sub hashes    { begin hash dup not until }      # ( n1 -- n2 )
sub hash>     { drop }                          # ( n -- )  end pic num conv - should convert
                                                # string stack to ( a n ) to comply with standard.
                                                # this version leaves converted number on top of string stack
sub sign      { negative if '-' hold endif }    # ( n -- }
sub brdotbr   { dup <hash hashes hash> sign }   # ( n -- )

sub padded  {                                   # ( n c -- )
   >r dup$ len$ -                                    # can't call it "pad" because pad is a
   0 max qdup if                                # standard word which does something else
      r@ repeat$ prepend$
   endif r> drop }



# --- "app" level number output words ---
# ( n -- ) signed number output with one trailing space
sub . { dup >r <hash bl hold  hashes r> sign hash> type$ }
sub dot { . }

# ( n u -- ) space padded signed number
sub .r { >r dup >r <hash hashes  r> sign  r> bl padded  hash> type$ }

# ( n -- )   zero padded signed number with one trailing space
sub .0r     { <hash  bl hold  times hash  hash> type$ }



# --- file editing buffer helpers
sub linelen { curline$ dup$ len$ drop$ }        # ( -- len )
sub at { movetocolumn movetoline }              # ( x y -- )



# --- run time defined macros - very crude, but it demonstrates the principle, and can be improved ---

sub ip        { var new }                       # instruction pointer. program counter for highlevel macros

sub branch    { ip @                            # runtime code for unconditional branch
                count +
                ip ! }

sub branch0   { if ip @ inc                     # runtime code for conditional branch
                else ip @ count +
                endif ip ! }

sub lit       { ip @                            # runtime code for literal numbers
                count swap
                ip ! }

sub compile   { tick
                qdup if comma
                else "xlerb?" type$
                endif }

sub literal   { "lit" compile
                comma }

sub run       { ip !                            # ( a -- )    start execution of high level macro at a
                begin lit                       # stealing from lit - happens to do the same as instruction fetch
                qdup while execute
                repeat  }


# --- define new macro class ---
sub macro       { here does run }               # our data construct builder is way cool ...

# --- build a macro ---

                                                
sub usermacro   { macro new                     # new data type "macro" :)
                  5 literal                     #    5
                  "dup" compile                 #    begin
                  "." compile                   #       dup .
                  "dec" compile                 #       dec
                  "qdup" compile                #       qdup
                  "not" compile                 #       not
                  "branch0" compile -7 comma    #    until
                  "cr" compile                  #    cr
                  0 comma                       #    exit
                  usermacro }                   # instantiate macro - great place to do that!
                                                # macro is ready, can be executed as "usermacro"
                                                # (actually, it is the other way around - when executed
                                                # the first time, macro will instantiate - and at the end
                                                # of instantiation, call itself here)

# --- initialisation ---
sub OnBoot    { decimal }

