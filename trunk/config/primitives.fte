# primitives.fte
#
# Copyright (c) 2008, eFTE SF Group (see AUTHORS file)
#
# You may distribute under the terms of either the GNU General Public
# License or the Artistic License, as specified in the README file.
#
# some tools and enhancements for macros.
# this are currently used for testing and toying
# with macros, as result many of the current macros
# assume these to be present, as factored out functionality.
#

# can't use this chars in names (yet):   = , # :
# TODO: fix bugs. a few words in here exist to work around known bugs.
#   insertstring:   prompts for string when trying to insert empty stringdd


# -- constants --
sub false     {  0 }
sub true      { -1 }                             # "true" represented as all bits sets
sub cell      {  1 }                             # memory increments per integer
sub cell+     {  1 + }
sub cell-     {  1 - }
sub cells     { }


# -- stack --
sub qdup      { dup will dup }                  # duplicate top of stack if <> 0
sub nip       { swap drop }                     # drop second of stack
sub tuck      { swap over }                     # copy top of stack below second of stack
sub pluck     { >r over r> swap }               # copy 3rd item to top
sub minrot    { 2:rot }                         # rotate top item below second item

sub dup2      { 2:over }                        # duplicate top two items
sub drop2     { 2:drop }                        # drop top two items
sub swap2     { rot >r rot r> }                 # swap top two pairs of items
sub @2        { dup @ swap 1 + @ }              # ( a -- x1 x2 ) double fetch, from 2 consecutive addresses
sub !2        { tuck 1 + ! ! }                  # ( x1 x2 a -- ) double store, to 2 consecutive addresses



# -- arithmetic, bool, bits, comparison  --
sub inc       { 1 + }                           # increment top of stack by one
sub dec       { 1 - }                           # decrement top of stack by one
sub invert    { -1 xor }                        # complement all bits
sub negate    { 0 swap - }                      # change sign
sub not       { 0 equals }                      # logical inversion: 0->true,  x->0
sub lshift    { 1 shift }                       # bit shift left by 1
sub rshift    { -1 shift }                      # bit shift right by one
sub <<        { shift }                         
sub >>        { negate shift }
sub success   { flag }                          # push command return code
sub failure   { flag not }                      # push inverted command return code
sub >         { swap < }                        # true if nos > tos
sub between   { rot tuck < minrot > or not }
sub negative  {  0 < }                          # -n
sub positive  { -1 > }                          # 0..n
sub abs       { dup 0 < will negate }           # remove sign
sub min       { dup2 > will swap drop }
sub max       { dup2 < will swap drop }
sub umin      { dup2 xor 0 < if max else min endif }  # ( u1 u2 -- u1|u2 ) unsigned min
sub umax      { dup2 xor 0 < if min else max endif }  # ( u1 u2 -- u1|u2 ) unsigned max
sub mod       { dup2 / * - }                    # modulo (remainder) function
sub percent   { * 100 / }
sub gcd       { begin tuck mod qdup not until } # greatest common denominator
sub sqrt      { 0 tuck do inc dup lshift inc +loop }
sub range     { over + swap }                   # start n -> limit start conversion for DO LOOP
sub +!        { dup >r @ +   r> ! }             # ( x a -- )  adds x to contents of address a
sub or!       { dup >r @ or  r> ! }             # ( x a -- )  bitwise  or x into address a
sub and!      { dup >r @ and r> ! }             # ( x a -- )  bitwise and x into address a
sub xor!      { dup >r @ xor r> ! }             # ( x a -- )  bitwise xor x into address a
sub toggle    { true swap xor! }                # ( a -- )  bitwise invert of contents of a

# --- define a variables class
sub var       { here dup cell allot }           # for the new construct:       sub foo { var new }


# --- number conversion words respect base, and convert accordingly
sub decimal   { 10 base ! }
sub hex       { 16 base ! }
sub octal     {  8 base ! }
sub binary    {  2 base ! }



# --- character test
sub bl        { ' ' }
sub capital   { 'A' 'Z' between }
sub lowercase { 'a' 'z' between }
sub capitalize { dup lowercase 32 and - }
sub undercast  { dup capital   32 and + }
sub printable  { bl 127 between }




sub cipher   {                                  # ( asc -- u -1 | 0 )  converts ascii to numeric value, and flag if legal cipher.
   capitalize '0' -                             #                      respects base, and reports only those chars valid which are
   dup 10 16 between or                         #                      legal in the resp. base
   dup 16 > 7 and -
   dup 0 base @ dec between
   qdup nip  }

sub numeric   { cipher dup will nip }           # ( asc -- flag )  flag if legal cipher.


# -- cursor --
sub cursorhome { movelinestart }
sub cursorend  { movelineend }



# need:
#  test block marked?


# =============================================================================
#    memory
# =============================================================================

sub off       { false swap ! }                  # ( a -- )   sets contents of a to false
sub on        { true swap ! }                   # ( a -- )   sets contents of a to true
sub count     { 1 + dup 1 - @ }
sub comma     { here cell allot ! }             # ( x -- )    allocate 1 location, initialized to x
sub exchange  { dup @ >r ! r> }                 # ( x1 a -- x2 )
sub link      { here swap exchange comma }      # ( a -- )
sub free      { memend here - }

sub scrape    { range do i @ loop }             # ( a n -- x0 x1 ... xn-1 )
sub spread    {                                 # ( x0 x1 x2 ... xn-1 a n -- )
   >r 1 - r>                                    # store xn at a+n
   range swap do 
      i ! 
   1 -loop }


# =============================================================================
#    strings
# =============================================================================

# thinking of
#  or$:  copy chars from string two into spaces of string 1
#  and$: replace chars in string one against space, if string2 has space on that pos
# example:
# string1:  "xxx    xxx"
# string2:  "1 345678 0"
# or$:      "xxx4567xxx"
# and$:     "x x    x x"
# xor$"     " x 4567 x "


sub nip$      { swap$ drop$ }
sub tuck$     { swap$ over$ }
sub minrot$   { 2:rot$  }
sub dup2$     { 2:over$ }
sub drop2$    { 2:drop$ }
sub equals$   { compare$ not }
sub prepend$  { swap$ append$ }


# TODO: can maybe simplify now after mid$ index fix.
sub cut$ {                                      # ( n -- )  s( $1 -- $2 $3 )  splits string at position n,
   dup if
      dup dup$ len$ + 0 >
      if 
         dup$ dup -1 mid$
         swap$ 0 swap mid$
         exit
      endif
   endif 
   drop ""
}


sub slice     { 1 cut$ asc }                    # ( -- asc ) cut first char off string and return as ascii
sub splice    { char$ prepend$ }                # ( asc -- ) prepend char to string
sub ascn      { dup$ 1 mid$ asc }               # ( n -- c ) get ascii of nth char in top string

# -- i/o --
sub key        { winrefresh getchar }           # wait for key, place its ascii on stack
sub read$      { curchar$ }                     # read char under cursor as string
sub read       { curchar$ asc }                 # read char under cursor as asc

sub emit       { typechar }
#sub type1      { count emit }
#sub type       { times type1 drop }             # string outpu
#TODO:  insertstring bug when empty string. workaround here.
sub type$      { dup$ len$ if dup$ insertstring endif drop$  }
#TODO: change insertstring to not behave funny when empty string is sent.
#TODO: output words more clearly taking account of mode:
#TODO:    insert insert$            always insert char or string
#TODO:    overtype overtype$        always overtype char or string
#TODO:    emit  type$               depends on overtype/insert mode

# stateful linenew may autoindent - workaround here
sub cr     {
    ?cursordown
    failure will lineadd
    cursorhome
    ?killtolineend
}




sub left$      {                                # ( n -- )
   dup 0 < if                                   # negative n: strip first n chars
      negate dup$ len$ over -
   else                                         # positive n: keep first n chars
      0 swap
   endif
   mid$ }


sub right$    {                                 # ( n -- )
  dup 0 < if                                    # negative n: strip last n chars
     0 swap
     dup$ len$ +
  else                                          # positive n: keep last n chars
     dup negate swap
  endif
  mid$ }




# unsigned number string to numeric
sub unumber? {                                  # ( -- n -1 | 0 )
   -1 0                                         # assume valid number, initial value 0
   dup$ len$ 0 do                               # loop through chars
      base @ *                                  #  accu*radix
      i ascn cipher if +                        #  next char valid cipher? yes: accumulate
      else
         2:drop 0 0 leave                       #  no: signal "not a number" and leave
      endif
   loop
   drop$
   swap qdup drop                               # return result as specified in stack diagram.
}


sub number? {                                   # ( -- n -1 | 0 )
   0 ascn '-' equals
   if
      -1 left$
      unumber?
      >r 
      r@ will negate 
      r>
   else
      unumber?
   endif
}






sub search$   {                                 # ( n1 -- n2 )
  true swap                                     # search though n1 string stack items,
  0 do                                          # matching against top string. returns
    i inc pick$                                 # item number of matching string as n2,
    over$ equals$                               # or -1
    if drop i leave endif
  loop
  drop$
}


sub embed$ {                                    # ( asc n -- ) store char at pos n of topmost string, overwriting
   dup dup$ left$                               # cut and keep chars left of write pos
   invert swap$ left$                           # cut and keep chars right of write pos (tricky)
   splice append$                               # recombine, with char between
}

sub capitalize$ {                               # ( -- )  capitalize all chars of top string
   dup$ len$ 0 do                               # loop though all chars:
      i ascn dup lowercase if
         capitalize
         dup i embed$                           #   replace char in string
      endif drop
   loop }


sub repeat$ {                                   # ( u c -- ) create a string of u times char
   swap ""
   qdup if
      over char$
      dup 1 do
         append$ dup$
      i +loop
      swap$ dup$ len$ - left$ append$
   endif
   drop
}

sub spaces$   { bl repeat$ }                    # ( u -- ) create a string of u spaces
sub spaces    { spaces$ type$ }
sub space     { insertspace }                   # print a space character



sub skip$ {                                     # ( asc -- idx )  search for first char which is not asc.
   -1                                           #                 index or -1 as result (not other than asc)
   dup$ len$ 0 do                               #                 drops string.
      over i ascn xor
      if drop i leave endif
   loop
   drop$ nip
   }


sub scan$ {                                     # ( asc -- idx )  search for first occurance of asc in string
   -1                                           #                 index or -1 as result.
   dup$ len$ 0 do                               #                 drops string.
      over i ascn equals
      if drop i leave endif
   loop
   drop$ nip }


sub split$    {                                 # ( asc -- )      cut string at asc, leaving left part as tos, rest as nos
   dup$ scan$                                   #                 if asc not found, leave whole string as tos, empty string as nos.
   dup 0< if
      drop dup$ len$
   endif
   cut$
#   swap$ -1 left$ swap$                        # remove asc from string remainder
   }

sub diags { diag diag$ }

sub minleading$ {                               # ( asc -- ) remove leading occurances of string
   dup$ skip$                                   # index, or -1 for no leading occurences of asc
   dup 0 < if  drop$ "" else
   dup     if  dup negate left$ endif
   endif drop
}



sub mintrailing$ {                              # ( asc -- ) remove trailing occurences of asc
   0                                            # assume no different chars
   0 dup$ len$ do                               # loop through string chars
      over i 1 - ascn                           # select chars, starting with last
      xor if                                    # until different asc
         drop i leave
      endif
   1 -loop
   left$                                        # keep left part except trailing asc
   drop }                                       



sub parse$ {                                    # ( asc -- )      search for asc in string, keep part left of asc.
   dup minleading$                              #                 skip leading asc first
   dup$ scan$
   dup -1 > if  dup left$  endif                #                 asc not found: return whole string, otherwise cut at asc
   drop }



# TODO: test with empty string, and spaces only string
sub trim$ {                                     # ( -- ) remove leading and trailing spaces
   bl minleading$
   bl mintrailing$ }



sub brmovebr$  {                                # ( a n -- )  copy n chars of tos$ to a
   swap dup2 ! inc
   swap range do
      slice i !
   loop drop$ }

sub move$    { dup$ len$  brmovebr$ }           # ( a -- ) transfers string on string stack to a


sub store$   {                                  # ( a -- ) transfers string on string stack to a
   count                                        # structure size
   2 cells -                                    # subtract space for structure size and leading string count
   dup$ len$ min                                # move smaller of this max and string size number of chars.
   brmovebr$
   }


sub combine {
   ""
   0 do                                         # for all chars in string do ...
      count char$ append$                       # get char and add to string
   loop drop }

sub fetch$    {                                 # ( a -- ) transfers the string at a to string stack.
   cell +                                       # skip first cell (containing amount of allocated space to string var)
   count
   combine }


sub comma$  {   # ( -- )     "comma" string to dp
   dup$ len$
   1 + dup comma
   here swap allot
   move$ }





sub var$ { here dup dup$ len$ inc dup inc comma allot } # string var description.


# --- debugging

sub println { print "\n" print }
sub pout    { 1 print }
sub perr    { 2 print }
sub poutln  { 1 println }
sub perrln  { 2 println }



# --- pictured number conversion ---
sub digit     { dup 10 < 3 xor '4' + + }        # ( u -- asc )
sub /mod      { dup2 / dup >r * - abs r> }      # ( n1 n2 -- r q )
sub <hash     { "" } 	  		                # ( n -- n ) start pictured num conversion with empty string
sub hold      { char$ prepend$ }                # ( n asc -- n )
sub hash      { base @ /mod swap digit hold }   # ( n1 -- n2 )
sub hashes    { begin hash dup not until }      # ( n1 -- n2 )
sub hash>     { drop }                          # ( n -- )  end pic num conv - should convert
                                                # string stack to ( a n ) to comply with standard.
                                                # this version leaves converted number on top of string stack
sub sign      { 0 < if '-' hold endif }         # ( n -- }

sub padded  {                                   # ( n c -- )
   >r dup$ len$ -                               # can't call it "pad" because pad is a
   0 max qdup if                                # standard word which does something else
      r@ repeat$ prepend$
   endif r> drop }



# ----- "app" level number output words -----
# ( n -- ) signed number output with one trailing space
sub .    { dup >r <hash bl hold  hashes r> sign hash> type$ }

# ( n u -- ) space padded signed number
sub .r { >r dup >r <hash hashes  r> sign  r> bl padded  hash> type$ }

# ( u n -- )  zero padded signed number, no trailing space
sub .00     { <hash times hash hash> type$ }


# ----- number conversion: integer to string, string to integer -----
sub number$   { dup <hash hashes hash> sign }   # ( n -- )
sub number    { number? not will fail }



# ----- date & time -----
sub time      { seconds  60 /mod 60 /mod 24 mod }    # ( -- s m h )
sub time$     { seconds 86400 mod                    # ( -- ) returns hh:mm:ss as string
               base @ >r
               <hash
                  2 0 do                     # wanted to factor st like    :00 :00  but have no good legal name)
                     decimal  hash
                     6 base ! hash
                     ':' hold
                  loop
                  decimal
                  2:hash
               hash>
               r> base ! }
sub .time   { time$ type$ }




# --- file buffer navigation ---
sub linelen    { curline$ dup$ len$ drop$ }         # ( -- len )
sub at         { 1 + movetoline  1 + movetocolumn } # ( x y -- )

sub cursorcolumn { at? drop 1 + }                   # ( -- x )
sub cursorrow    { at? nip  1 + }                   # ( -- y )

sub emptybuffer {
   movefilestart blockbegin
   movefileend    blockend
   ?blockkill
}

sub cls        { emptybuffer }                      # wipe current buffer

sub linecount  {                                    # ( -- u ) number of lines in file
   at? movefileend
   cursorrow minrot
   at }



sub blockmove   { blockcut blockpaste }             # move block to cursor

# sub sleep  { winrefresh ms }  # winrefresh doesn't do what i hoped it would



# ---- user/app stacks ----

# structure:   sp size *push *pop *item *items item0 item1 ...
#   * indicate execution vectors: an address, containing an execution token.
#   they can be seen as methods, invoked when a message demands their execution.


sub pop1 {                              # ( a -- x )
   dup @                                # read stack pointer
   dup 7 < will fail                    # would point to stack meta data below stack items
   1 - swap                             # decrement stack pointer
   dup2 ! + @                           # store new stack pointer, add index to stack base, fetch item.
}


sub push1 {                             # ( x a -- )
   dup @2                               # read pointer and size
   over < will fail                     # protect against overflow
   dup2 1 + swap !                      # increment stack pointer. store in meta data
   + !                                  # calc item address and store item.
}

sub item1 {                             # ( n a -- x )
   over 0 < will fail                   # reading below first item
   tuck @ 7 - over < will fail          # reading above last item
   6 + + @                              # read and return item
}

sub items1 { @ 6 - }



# --- new stack class ---
# called stack1 because of single cell items.
# will need double and triple cell items stack, those will be called stack2 resp. stack3, and
# push/pop 2 resp 3 items. for bookmarks - global bookmarks want x, y and file as one single logical item.
# for now single item only, to test the stack creation and action messaging logic.

sub stack1 {                            # create: ( size -- )    run:  ( -- a )
    >r here                             # keep stack size, obtain stack base address (metadata address)
    6 comma                             # initial stack pointer (behind meta data)
    r@ 5 + comma                        # stack size for overflow test: metadata+items-1
    "push1" tick comma                  # execution vector to stack push, "method" like
    "pop1" tick comma                   # execution vector to stack pop, "method" like
    "item1" tick comma                  # execution vector to stack peek, "method" like.
    "items1" tick comma                 # execution vector to stack peek, "method" like.
    r> allot }                          # allocate space for items






# --- stacks with dual items ---
# structure:   sp size *push *pop *item *items item0a item0b item1a item1b ...


sub pop2 {                              # ( a -- x )
   dup @                                # read stack pointer
   dup 7 < will fail                     # would point to stack meta data below stack items
   2 - swap                             # decrement stack pointer
   dup2 ! + @2                          # store new stack pointer, add index to stack base, fetch item.
}


sub push2 {                             # ( x a -- )
   dup @2                               # read pointer and size
   over < will fail                      # protect against overflow
   dup2 2 + swap !                      # increment stack pointer. store in meta data
   + !2                                 # calc item address and store item.
}

sub item2 {                             # ( n a -- x )
   over 0 < will fail                    # reading below first item
   >r  dup +                            # get a out of the way and index>offset
   r@ @ 7 - over < will fail             # reading above last item
   6 +  r> + @2                         # read and return item
}

sub items2 { @ 6 - rshift }

sub stack2 {                            # create: ( size -- )    run:  ( -- a )
    lshift >r here                      # calc stack size, obtain stack base address (metadata address)
    6 comma                             # initial stack pointer (behind meta data)
    r@ 5 + comma                        # stack size for overflow test: metadata+items-1
    "push2" tick comma                  # execution vector to stack push, "method" like
    "pop2" tick comma                   # execution vector to stack pop, "method" like
    "item2" tick comma                  # execution vector to stack peek, "method" like.
    "items2" tick comma                 # execution vector to stack peek, "method" like.
    r> allot }                          # allocate space for items




# --- stacks with triple items ---
# structure:   sp size *push *pop *item *items item0a item0b item0c item1a item1b item1c ...

sub @3 { 3 scrape }                     #  ( a -- x1 x2 x3 )
sub !3 { 3 spread }                     # ( x1 x2 x3 a -- )

sub pop3 {                              # ( a -- x )
   dup @                                # read stack pointer
   dup 7 < will fail                     # would point to stack meta data below stack items
   3 - swap                             # decrement stack pointer
   dup2 ! + @3                          # store new stack pointer, add index to stack base, fetch item.
}


sub push3 {                             # ( x a -- )
   dup @2                               # read pointer and size
   over < will fail                      # protect against overflow
   dup2 3 + swap !                      # increment stack pointer. store in meta data
   + !3                                 # calc item address and store item.
}

sub item3 {                             # ( n a -- x )
   over 0 < will fail                    # reading below first item
   >r  3 *                              # get a out of the way and index>offset
   r@ @ 7 - over < will fail             # reading above last item
   6 +  r> + @3                         # read and return item
}

sub items3 { @ 6 - 3 / }

sub stack3 {                            # create: ( size -- )    run:  ( -- a )
    3 * >r here                         # keep stack size, obtain stack base address (metadata address)
    6 comma                             # initial stack pointer (behind meta data)
    r@ 5 + comma                        # stack size for overflow test: metadata+items-1
    "push3" tick comma                  # execution vector to stack push, "method" like
    "pop3" tick comma                   # execution vector to stack pop, "method" like
    "item3" tick comma                  # execution vector to stack peek, "method" like.
    "items3" tick comma                 # execution vector to stack peek, "method" like.
    r> allot }                          # allocate space for items






# --- stack type independent ---
sub push  { dup 2 + @ execute }         # "message" executes push vector from stack meta data
sub pop   { dup 3 + @ execute }         # "message" executes pop  vector from stack meta data
sub item  { dup 4 + @ execute }         # returns an indexed stack item
sub items { dup 5 + @ execute }         # returns number of items on stack.



# example of use:
# define a new stack:
#      sub foo  { stack1 new }
# execute at init time, to set stack size and allocate stack space:
#      sub InitWhatever   { ... (other init)    8 foo     ... (more init)  }
# push to stack:
#      n foo push
# pop from stack:
#      foo pop
# stack depth:
#      foo items
# stack peek:
#      n foo item


# --- arrays ---

sub array {
  here swap dup 1 + comma allot
  does
     >r
     dup 0 < will fail
     1 +  r>
     dup2 @ < not will fail
     + }

sub array2 {
  here swap lshift dup 1 + comma allot
  does
     >r
     dup 0 < will fail
     lshift 1 +  r>
     dup2 @ < not will fail
     + }

# 3 elements per entry  (suitable for x, y, file to use with slotted bookmarks)
sub array3 {
  here swap 3 * dup 1 + comma allot
  does
     >r
     dup 0 < will fail
     3 * 1 +  r>
     dup2 @ < not will fail
     + }


# set array size at instatntiation:    sub foo { array new }      { ... 5 foo ... }


# ----------------------------------- file name stack --------------------------------------
# random access stack of filenames. adding returns token. token converts to filename


sub FileStack { stack1 new }         # single items (pointers to file names)


sub AddFile {                        # ( -- n )    file name passed as string. add to filestack
   filestack items
   here comma$
   filestack push }


sub FileName {                       # ( token -- )    put filename on string stack
   fileStack item fetch$  }


sub FindFile {                       # ( -- -1 | token )  file name as string
   -1
   filestack items 0 do
      dup$  i filename equals$
      if
         drop i
         leave
      endif
   loop drop$ }


sub File  {                          # ( -- n )  given filename as string, adds it to filestack if not already in it. returns file token
   dup$ FindFile
   dup negative if
      drop
      dup$ AddFile
   endif
   drop$ }


# example of use:
# obtain token for filename:   (creates new filestack entry if needed, i.e. if new file)
#       filename$ file
# obtain filename for token:
#       filename


# ----------------------------------- bookmarks --------------------------------------
# TODO: local bookmarks: only pop if filename$ matches bookmark creator.
# TODO: local bookmarks: 1 stack per file? use an aggregated stack?   aggregated may call for roll.
#       advantage of aggregated: identical push operation for local and global. one stack for all.
#       only difference is pop bookmark: local restore searches for own file, global uses top.



# ----------- stacked bookmarks. push to save, pop to restore -----------

# global bookmarks: bookmark stack. location 0  is stack pointer. 1 is max size.
sub BookMarkStack { stack3 new }     # stack3 = 3 items per stack item.  cursor x, y and file handle

sub PushBookmark {
    at? filename$ file
    bookmarkstack push
}

sub PopBookmark {
    bookmarkstack pop
    filename fileopen at
}

# ----------- slotted bookmarks. store to save, fetch to restore. restore is non-destructive ------------

sub BookmarkSlot  { array3 new }

sub SaveBookmark  {                 # ( n -- )
    >r at? filename$ file
    r> BookmarkSlot !3
}

sub FetchBookmark  {                # ( n -- )
    BookmarkSlot @3
    dup negative will fail
    filename fileopen at
}

# ----------- initialize both type of bookmarks ------------

sub InitBookmarks {
   256 FileStack
   512 BookmarkStack    # for push/pop bookmarks
# for slotted bookmarks. instantiate and initialize to "unused" (so that fetch attempt will fail)
# need more bookmarks? increase 10 to the number you need.
   10 dup BookmarkSlot 0 do -1 -1 -1  i Bookmarkslot !3 loop
 }



# -------- attempting to save configuration - writing to other files is more difficult than expected --------

sub SaveFilename  { '"' emit  filename type$ '"' emit " file " type$ space }
sub SaveBookmarks {
   "sub RestoreBookmarks {"  type$ cr
   10 0 do
      i Bookmarkslot @3
      dup positive if
         4 spaces
         rot . swap . SaveFilename
         i . "bookmarkslot !3" type$  cr
      else
         drop2 drop
      endif
   loop
   Bookmarkstack items 0 do
      i bookmarkstack item
      4 spaces
      rot . swap . SaveFilename
      "bookmarkstack push" type$ cr
   loop
   "}" type$ cr

}


sub SaveDesktop  {
   "desktop.fte" ?fileopen
   filename$
   begin
      ?filenext
      dup$ filename$ equals$
   not while
#      filename$ over$ diag$ To
   repeat
   drop$
}

sub To {                                                      # str1 filen
    ?fileopen
#    type$
#    filesave
    fileclose
  drop2$
}

sub In {                                                      # ( a -- )  s( filenm )
    fileopen
    execute
    filesave
    fileclose
}

sub xxx {
    10 0 do
       cr i .
       filename$
       "test" "foobar" to
       ?fileopen
    loop
}




# --- context variables ---
# contrary to vars, which are global, contextvars values are local to their respective context,
# while their symbols are global. you can see them as global vars which can contain many
# values. which value is visible, depends on the context.
# a context can be saved and restored by reading from and writing to var activecontext. named
# contexts can be created by instantiation of class context.


sub contextsize     { 64 }
sub activecontext   { var new }
sub contextvars     { var new }
sub contextvar      { 1 contextvars dup @ >r +! r> does activecontext @ + }
sub context         { here contextsize allot does activecontext ! }

# -- yes, that's all. :)

# example of use:

sub context1        { context new }         # create a new named context
sub context2        { context new }         # and another.   executing these activates the resp contexts.

sub foo             { contextvar new }      # a context variable
sub bar             { contextvar new }      # and another

# unluckily, we need to initialize the whole lot - can't do that at compile time yet.
# "initializing" does not just mean "adding a defined value" - it means "instantiate" including mem allocation
sub InitContext {
#   0 activecontext !       # init var, containing context base address. not needed: activating a context instantiates activecontext.
   0 contextvars !         # init var, containig next context var offset
   context1                # init instance of context
   context2                # init instance of context
   context1                # execute instance, making this context active
   foo                     # init context var
   bar                     # init context var
}

# sub contextdemo  {
#   context1      100 foo !   200 bar !
#   context2      11  foo !   22  bar !
#   context1      foo @ .  bar @ . cr
#   context2      foo @ .  bar @ . cr
# }

# targetted to support the (non-existing) multitasker, allowing tasks to set
# context-local contexts of misc variables. a good candidate for a context
# variable would be the current global var   base (number i/o radix) so that
# each task can have base in its local context.

# may be of use for file type modes, with an own set of variable settings for each.


# --- data type flip flop ---
# flip flop instances instances contain a state, which is toggled and
# returned upon execution
sub flipflop { here 0 comma does dup toggle @ }

# example:
# sub yesno { flipflop new }
# sub makeupyourmind { yesno if "yes" else "no" endif  type$ }
# as usual, instances must be initialized:
#    { ... yesno .... }



# --- migrated toggles ---
sub ToggleTrim   { autotrim toggle }
sub ToggleInsert { insert toggle }


# --- initialisation ---
sub attempt   { tick execute }                      # execute macro, name given as string, if existing
sub OnBoot    {
   decimal
   insert on
   InitBookmarks                                    # don't need to attempt - init it right above.
   InitContext
   "InitMySettings"  attempt
   "InitSelftest"    attempt
   "InitInterpreter" attempt
   }

