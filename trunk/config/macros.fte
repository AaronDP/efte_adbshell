# macros.fte
#
# Copyright (c) 2008, eFTE SF Group (see AUTHORS file)
#
# You may distribute under the terms of either the GNU General Public
# License or the Artistic License, as specified in the README file.
#
# Additional macros provided by eFTE
#

# ( -- LineLen CurCol )
#
# Push the line range onto the stack for iterating via a Do ... Loop
#
sub linerange { linelen cursorrow }

# ( -- endingRow startingRow )
#
# Push the block range onto the stack for iterating via a Do ... Loop
#
sub blockrange { moveblockend cursorcolumn moveblockstart cursorcolumn }

# ( ch -- num )
#
# Return True/False if the current character is equal to Tos
#
sub iscursorchar    { read equals }


# ( -- )
#
# Eat all but one whitespace (backwards)
#
sub eatwhitespaceback {
  ?2:cursorleft  # leave at least 1 white space
  begin
    bl iscursorchar
    dup if
      killchar
      ?cursorleft success and
    endif
  not until
  ?2:cursorright # go back to original location (minus whitespace)
}

# ( ch -- pos )
#
# Goto character in the current line
#
# pos = -1 if not found
#
sub gotocharinline {
  -1
  cursorhome
  linelen 0 do
    over iscursorchar
    if
       drop
       cursorcolumn
       leave
    endif
    cursorright
  loop
  nip
  dup 0 < will cursorhome
}

# ( -- )
#
# Align the specified character in each line of the selected block
#
# Example:
#    int a = 10;
#    int abc = 20;
#    int ad            = 30;
#
# Result:
#    int a   = 10;
#    int abc = 20;
#    int ad  = 30;
#
sub alignchar {
  key
  -1
  blockrange do
    over gotocharinline drop
    eatwhitespaceback
    cursorcolumn max
    cursordown
  loop

#  moveblockstart   ( blockrange moves cursor anyway? maybe it shouldn't, but restore to org pos )
  dup positive if             # only do this if char was actually found
    blockrange blockunmark do
      over gotocharinline
      dup positive if dup2 - spaces endif drop
      cursordown
    loop
  endif
  drop2

}

# ( -- )
#
# Join current line with line below eatting all whitespace in
# between except one
#

sub GreedyJoinLineNext {
    CursorDown MoveFirstNonWhite EatWhiteSpaceBack
    CursorUp MoveLineEnd KillChar
}




#********************************************************************************
#
#
#                       bubble lines or blocks up/down
#
#   suggested key bindings:  (these keys are by default assigned to prev/next window)
#        key [A+G-Up]        { bubbleup }
#        key [A+G-Down]      { bubbledown }
#
#
#*********************************************************************************



sub bubbleblock {                               # ( direction -- )
    >r  cursorcolumn cursorline
    dup2 withinblock if r@ + endif              # trap cursor and move along if in block
    moveblockstart
    r> negative if                              # move up requested
       ?cursorup
    else
       cursorcolumn
       blocktype 3 xor will moveblockend
       ?cursordown
#       failure if ... deal with last line ... endif
       movetocolumn
    endif blockmove
    movetoline movetocolumn
}

sub bubbleblockup     { -1 bubbleblock }
sub bubbleblockdown   {  1 bubbleblock }

sub dumbbubblelineup  {                         # can't deal with last line properly
    cursorcolumn
        cursorup cursorhome
        blockselectline
        ?bubbleblockup
        blockunmark
    movetocolumn   }


# should make this work with blocks and call from bubbleblock instead.
# that way, both lines and blocks take advantage of last line handling.
sub bubbleuplast      {                         # last line needs special handing,
    lineadd dumbbubblelineup                    # if not terminated by eol.
    cursordown linejoin cursorup }

sub bubblelineup {
    ?cursordown failure
    if      bubbleuplast
    else    dumbbubblelineup
    endif  }

sub bubblelinedown {
    cursordown
    bubblelineup
    cursordown }

sub bubbleup {                                  # put this one on key.  Using [A+G-Up] here
    block if bubbleblockup
    else     bubblelineup
    endif    }

sub bubbledown {                                # put this one on key.  Using [A+G-Down] here
    block if bubbleblockdown
    else     bubblelinedown
    endif    }



#********************************************************************************
