%if(!BLOCKS)
%define(BLOCKS)

# --- blocks ---

sub blockmove { blockcut blockpaste }           # move block to cursor

# no symbols yet for the data in the new block information structure,
# therefore hardcoded offsets into the structure. it has the following layout:
#  block+0: block type (0=none, 1=line, 2=stream, 3=column).
#  block+1: column of block begin.
#  block+2: line of block begin.
#  block+3: column of block end.
#  block+4: line of block end.
# latter 4 only contain meaningful values if block type is 1..3
#
#

# TODO: fail handler must empty controlstack

sub blocktype     { block @ }                   # ( -- f )

# correct block bottom coordinate to be within block
sub lineblockbottomcorrection {                 # ( column1 line1 -- column2 line2 )
    1 - >r drop
   r@ line$ len$ r>  }

sub streamblockbottomcorrection {               # ( column1 line1 -- column2 line2 )
    >r 1 - r>  }

sub columnblockbottomcorrection {               # ( column1 line1 -- column2 line2 )
    1 - >r 1 - r> }

sub blockcoordinate  {                          # ( a1 -- u a2 )
    dup @ 1 + swap 1 + }

sub blockcoordinates {
    block count dup >r
    not will fail
    4:blockcoordinate drop
    r> vector
       fail
       lineblockbottomcorrection
       streamblockbottomcorrection
       columnblockbottomcorrection
    endvector  }


sub blocktop    {                               # ( -- column line )  one-based
    blockcoordinates drop2  }

sub blockbottom  {                              # ( -- column line )  one-based
    blockcoordinates swap2 drop2  }




# TODO: let these take advantage of the above words:
#   replace the block n + @, and convert to one-based
sub abovelineblock    {                         # ( column line first -- f )  helper word for withinblock
    < nip }

sub abovestreamblock  {                         # ( column line first -- f )  helper word for withinblock
    dup2 <
    if  3:drop true exit endif
    equals if  block 1 + @ > not exit endif
    drop false  }

sub abovecolumnblock  {                         # ( column line first -- f )  helper word for withinblock
     < swap
    block 1 + @
    > not or }

sub aboveblock  {                               # ( column line -- f )        helper word for withinblock
    block 2 + @ 1 +
    blocktype vector
        fail
        abovelineblock
        abovestreamblock
        abovecolumnblock
    endvector  }



sub belowlineblock    {                         # ( column line last -- f )  helper word for withinblock
    < not nip }

sub belowstreamblock  {                         # ( column line last -- f )   helper word for withinblock
    dup2 >
    if 3:drop true exit endif
    equals if  block 3 + @ > exit endif
    drop false  }

sub belowcolumnblock  {                         # ( column line last -- f )  helper word for withinblock
    < not  swap
    block 3 + @ > or }

sub belowblock  {                               # ( column line -- f )        helper word for withinblock
    block 4 + @ 1 +
    blocktype vector
       fail
       belowlineblock
       belowstreamblock
       belowcolumnblock
    endvector }


sub withinblock  {                              # ( column line -- f )
    blocktype not if drop2 false exit endif
    dup2 aboveblock
    if    drop2 false
    else  belowblock not
    endif
}


sub cursorwithinblock {                         # ( -- f )
    cursorcolumn cursorline withinblock
}


# --- block stack ---

sub lineblock { 1 }
sub streamblock { 2 }
sub columnblock { 3 }


sub restorelineblock {
    at? >r >r
    blockunmark
    movetoline drop blockmarkline
    movetoline drop blockmarkline
    r> r> at }

sub restorestreamblock {
    at? >r >r
    blockunmark
    movetoline movetocolumn blockmarkstream
    movetoline movetocolumn blockmarkstream
    r> r> at }

sub restorecolumnblock {
    at? >r >r
    blockunmark
    movetoline movetocolumn blockmarkcolumn
    movetoline movetocolumn blockmarkcolumn
    r> r> at }

sub drop4 { 4:drop }


include "stacks.fte";

sub BlockStack { stack5 new }        # blocktype, startcolumn, startline, endcolumn, endline

sub pushblock  {
    block count >r
    4:blockcoordinate drop
    r>  blockstack push
}

sub popblock   {
    blockstack pop
    vector
       drop4
       restorelineblock
       restorestreamblock
       restorecolumnblock
       fail
    endvector }


# converts one block type to another.
# converting line to column block doesn't work yet
# factor!
sub convertblock  {                             # ( blocktype -- )
    >r pushblock
    blockstack pop
    drop r>
    vector
       drop4
       restorelineblock
       restorestreamblock
       restorecolumnblock
       fail
    endvector }







sub fillcolumnblock  {                          # ( c -- )
    blockbottom >r blocktop 1 - >r 1 - r> r> swap
    do  dup2 do
       pluck i j char!
    loop loop
    3:drop }

sub fillstreamblock  {                          # ( c -- )
    pushblock
    blockbottom >r blocktop 1 - >r 1 - r> r> swap
    do  dup2 do
       pluck i j char!
    loop loop
    3:drop
    popblock }


sub fillblock {                                 # ( c -- )
    blocktype vector
       fail
       fail
       fillstreamblock
       fillcolumnblock
    endvector  }


sub InitBlocksAlready  { var new }
sub InitBlocks {
    InitBlocksAlready @ unless
        InitBlocksAlready on
        256 BlockStack
}

%endif
