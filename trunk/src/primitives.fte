#
# some tools and enhancements for macros.
# this are currently used for testing and toying
# with macros, as result many of the current macros
# assume these to be present, as factored out functionality.
#
# -- constants --
sub Zero      { 0:Push }
sub False     { Zero }
sub One       { 1:Push }
sub True      { -1:Push }                  # "true" represented as all bits sets

# -- bool, bits, comparison  --
sub Invert    { -1:Push; Xor }             # complement all bits
sub Not       { Zero; Equals }             # logilal inversion: 0->true,  n->0
sub LeftShift { Dup; Plus }                # bit shift left once
sub Failure   { Flag; Not }
sub Success   { Flag }
sub More      { Swap; Less }               # true if nos > tos

# -- stack --
sub Qdup      { Dup; If; Dup; EndIf }      # duplicate top of stack if <> 0
sub Nip       { Swap; Drop }               # drop second of stack
sub Tuck      { Swap; Over }               # copy top of stack below second of stack
sub Dup2      { Over; Over }               # duplicate top two items
sub Drop2     { Drop; Drop }               # drop top two items
sub Swap2     { Rot; ToR; Rot; RFrom }     # swap top two pairs of items
    
# -- arithmetic --
sub Inc       { One; Plus }                # increment top of stack by one
sub Dec       { One; Minus }               # decrement top of stack by one
sub Negate    { Invert; Inc }              # change sign
sub Abs       { Dup; Zero; Less; If; Negate; EndIf} # remove sign
sub Min       { Dup2; More; If; Swap; EndIf ; Drop }
sub Max       { Dup2; Less; If; Swap; EndIf ; Drop }
sub Mod       { Dup2; Div; Mul; Minus }    # modulo (remainder) function
sub Gcd       { Begin; Tuck; Mod; Qdup; Not; Until; }  # greatest common denominator

# -- i/o --
sub Space     { InsertString " " }         # print a space character
#sub Spaces   { For; Space; Next }         # don't have loops yet
sub Spaces    { Begin; Qdup; While; Space; Dec; Repeat } # print number of spaces as specified by top stack item
sub Cr        { LineNew }                  # carriage return
sub Ok        { InsertString " ok "; Cr }  # meant to be used as prompt
sub Dot       { InsertString $Tos; Space } # output top stack item as number
sub Key       { GetChar; }                 # wait for key, place its ascii on stack
# sub Type    { Zero; Do; Count; Emit; Loop; Drop } # string output

# -- cursor --
sub CursorHome { MoveLineStart }
sub CursorEnd  { MoveLineEnd }


# need:
#  Allocate
#  Fetch
#  Store
#  Emit
#  some way to print to status bar, or hook up a macro for executing when status bar is updated.


