%if(!FIRESHELL)
%define(FIRESHELL)

sub last         { var new }                    # anchor of linked list through words
sub state        { var new }                    # compilation/interpretation switch
sub w            { var new }                    # VM word pointer
sub ip           { var new }                    # VM instruction pointer
sub loading      { var new }
sub baseprefix   { var new 35 allot }           # associate number base prefix with number base
sub shellindent  { var new }
sub compiling    { state @ }
sub interpreting { compiling not }



# --- virtual machine ---
sub exec      {
   dup -65536 and
   if
      dup 1 + w ! @
   endif
   execute }


sub donest    {
   ip @ >r                                      # push return address
   w @ ip !                                     # set instruction pointer to called macro
   begin                                        # having an efte support command here would speed this up.
      ip @
      dup 1 +
      ip !
   @ qdup while
      exec
   repeat
   r> ip !
   }



# --- run time words ---

sub dovar     { w @ }                           # push data address

# not factoring here for .. hmm .. "performance" :D
sub branch    { ip @                            # runtime code for unconditional branch
                dup @ +
                1 + ip ! }

sub branch0   { if ip @                         # runtime code for conditional branch
                else ip @ dup @ +
                endif  1 + ip ! }

sub dodo      {
   dup2 equals if
         drop2
         ip @
         dup @ + 3 +
   else  swap >r >r
         ip @ 1 +
   endif ip !
                }

sub doloop    {                                 # runtim code for simple count up loops
   r> 1 +
   dup r@ xor if
      >r  ip @ dup @ + ip ! exit
   endif
   r> drop2
   ip @  1 + ip !
}


sub lit       { ip @                            # runtime code for literal numbers
                dup 1 + ip !
                @
               }

sub slit      { ip @                            # runtime code for literal strings
                count
                dup2 + ip !
                combine
               }



# --- "buffered i/o", source line parsing ---

sub source$ { var$ new }

sub word$   {                                   # ( c -- )  must clear input line from string stack
    source$ fetch$                              # this is a but cludgy and slow, but the easiest way for now/
    dup bl equals if
       dup minleading$
    endif
    split$
    swap$ -1 left$
    source$ store$
    }



sub prompt  {
   loading @ not if
      interpreting if
         "[ok]" type$
         depth$ '$' repeat$ type$
         depth  '.' repeat$ type$
         cr
      else
         shellindent @ spaces
      endif
   endif
 }




# TODO: check split$ / word$ with leading spaces - there may be a stack imbalance.
# TODO: repeated  1 + dup @ .  , printing last address after a while (non-alloc'd mem) stack error?


sub query    {     # ( -- n )
   curline$

# replace control chars (including tabs) against spaces
   dup$ len$ 0 do
      i ascn
      dup bl <
      if
         bl i embed$
      endif
      drop
   loop

   bl minleading$
   dup$ source$ store$
   len$
}


sub endloading {
   loading off
   fileclose
   }


sub error    {
   shellindent off
   state off
   false loading exchange
   qdup if
      " while loading from " append$ filename$ append$
      ", line " append$ <hash hashes hash> append$
      fileclose
   endif
   cr type$ cr
   fail }

sub notfound { "Undefined word: " prepend$ error }


# --- dictionary ---

sub revealbit      { 1 }
sub precedencebit  { 2 }


# --- header structure ---
#         --- lfa ---
# link+0  pointer to prev word
#         --- cfa ---
# link+1  pointer to xt
#         --- nfa ---
# link+2  header flags
# link+3  name len
# link+4+ name
#         ---
#   xt    xt of word handler
#         body
#         ...


sub >xt       { @ }                # ( cfa -- xt )
sub >body     { >xt 1 +  }         # ( cfa -- body )
sub link>     { 1 + }              # ( lfa -- cfa )
sub >link     { 1 - }              # ( cfa -- lfa )
sub >name     { 1 + }              # ( cfa -- nfa )
sub name>     { 1 - }              # ( -- cfa )
sub name$     { fetch$ }
sub .name     { fetch$ type$ }
sub headerflags { @  }             # ( nfa -- flags )
sub latest    { last @ link> }
sub immediate { precedencebit    latest >name   or! }   # ( -- )
sub reveal    { revealbit        latest >name   or! }   # ( -- )
sub hide      { revealbit invert latest >name  and! }   # ( -- )



sub header {
   last link                       # add new header to linked list of headers
   here 0 comma                    # pointer to word body
   0 comma                         # header flags
   here
   dup$ len$ 1 + allot
   move$
   here swap ! }


sub nextheader  {                   # ( cfa1 -- cfa2 | 0 )
   >link @
   dup will link>
   }


sub findheader  {                   # ( cfa -- xt headerflags | 0 )
   begin
      dup >name                     # cfa nfa
      dup headerflags               # cfa nfa headerfl
      dup revealbit and
      if
         dup$
         over name$ equals$
         if
            drop$
            >r drop >xt r>
            exit
        endif
      endif
      drop2
  nextheader
  dup not until
  drop$
}


sub locate {             # ( -- xt headers | 0 )   search for word name on string stack
   dup$
   latest findheader
   qdup if
      drop$
   else
      tick
      dup will revealbit
   endif
 }


sub postpone   {
   dup$ locate
   if drop$ comma
   else notfound
   endif }


sub create    {
   bl word$ header
   "dovar" postpone
   reveal }


sub sub {
   bl word$ header
   "donest" postpone
   state on
   5 shellindent !
   }


sub endsub  {
   shellindent off
   0 comma
   state off
   reveal }



sub newtick {
   bl word$
   dup$ locate
   not will notfound
   drop$
}


sub literal   {            # compiling: ( x -- ),  interpreting: ( x -- x )
   compiling if
      "lit" postpone
      comma
   endif }


sub sliteral  {
   compiling if
      "slit" postpone         #     compile as string literal:
      here                    #     .. goes string to
      dup$ len$ 1 + allot     #     allocate string len + 1 (for leading count)
      move$                   #     place string
   endif }


sub baseprefix$  { var$ new  }

# --- compiler/interpreter ---

# needs some serious factoring out here.
sub maybesomethingelse {         # ( -- f ) not a word in dictionary - try alternatives
   dup$
   number? if
      literal                    # yes, compile number (if compiling)
      drop$                      # (kept for error case)
      true exit
   endif

   0 ascn 39 equals if           # 'x'
      1 ascn literal
      drop$
      true exit
   endif

   0 ascn
   baseprefix$ fetch$ scan$      # $xxxx  #nnnn  %100101  style of number base designator?
   dup 0< if
      drop
   else
      baseprefix + @             # read number base
      base exchange >r           # use
      dup$ -1 left$              # strip prefix from what could be a number
      number?                    # is it?
      r> base !
      if                         # yes, compile number, or leave on stack.
         literal
         drop$
         true exit
      endif
   endif

   0 ascn '"' equals if          # unknown word starts with double quotes?
      -1 left$                   # remove leading "
      -1 ascn  '"' equals        # last char " ?
      if                         # yes: string without spaces, completely parsed
         -1 right$               # remove trailing "
      else                       # no: need to parse rest of string
         " " '"' word$ 2:append$ # parse rest of string
      endif
      sliteral                   # compile string to word, or leave on stack
      true exit

   endif
   false
 }




# the interpreter/compiler. source expected in variable source$
sub interpret {                         # ( -- )
    begin
       bl word$
       dup$ len$                        # still input?
    while
       dup$ locate                      # look up in dictionary
       qdup if                          # found:
          drop$                         # (kept name for not-found case)
          precedencebit and             # immediate words execute always
          interpreting or
          if
             exec                       # not compiling or immediate: execute straight away.
          else
             comma                      # compile execution token to mem
          endif
       else                             # word not in dictionary: test for alternatives, like:
          maybesomethingelse            #   "strings"  'A'sciis  $hex  #decimal  %binary numbers
          not will notfound
       endif
    repeat
    drop$
    }


sub interpret$  {                       # ( -- ) s( sourceline -- )
    source$ store$ interpret
}


sub load {                              # compile from file.  not nestable now.
   bl word$ fileopen
   0 0 at
   1 loading !
   linecount 0 do
      query will interpret
      ?cursordown
      1 loading +!
   loop
   endloading
#   cr
}


sub ok {
    query
    loading @ not will cursorend
    if
       space
       interpret
       cr
    endif
    prompt }





sub addbaseprefix {                                     # ( c n -- )
    baseprefix$
# -- high information hiding potential here:
#      calculate how much string space of this string variable is left
       dup @ over 1 + @ 2 + -
    not will fail
# --
    fetch$
    dup$ len$ baseprefix + !
    char$ append$
    baseprefix$ store$
    }

sub removebaseprefix {                                  # ( -- )  removes the most recently added prefix.
    baseprefix$ fetch$
    dup$ len$ not will fail
    -1 right$
    baseprefix$ store$ }




sub fireshellenable { var new }
sub Fireshell       { fireshellenable @ if ok else linenew endif }
sub bye             { fireshellenable off }


# --------- fireshell utilities ---------


sub words {
  base @ hex
  last
  cr
  30 '-' repeat$
  dup$ type$ cr   # seperator
  " addr f name" type$ cr
  dup$ type$ cr   # seperator
  begin @
  qdup while
     dup link>
     dup .
     >name  dup headerflags
     revealbit precedencebit or and
     "- -#" 1 mid$ type$ space
     .name cr
  repeat
  type$           # seperator
  base ! }




# --------- hexdump, words, utilities ---------

sub slashstring { over min tuck - >r + r> }             # ( a1 u1 u -- a2 u2 )

sub safeemit    {                                       # ( asc -- )
    count dup printable
    not if
      drop '.'
    endif
    emit
}


sub hexdigits   { base @ >r hex   <hash bl hold times hash hash> type$  r> base ! }
sub .addr       { 8 hexdigits }                         # ( a -- )
sub .byte       { 2 hexdigits }                         # ( c -- )
sub .nextbyte   { count .byte }                         # ( a1 -- a2 )
sub dumpbytes   { times .nextbyte drop }                # ( a n -- )
sub dumpchars   { times safeemit drop }                 # ( a n -- )

sub dump1line  {                                        # ( a n -- )
   dup if
      over .addr space
      dup2 dumpbytes
      16 over - 3 * 2 + spaces    # pad with spaces to ascii dump. a dumpline could be < 16 bytes.
      dup2 dumpchars
   endif drop2 }


sub dump {                                              # ( a n -- )
   cr
   begin
      dup
   while
      dup2 16 min dump1line cr
      16 slashstring
   repeat drop2
}



# ---------------- initialise ---------------

sub colondef        { header "donest" postpone }


sub InitFireshellAlready  { var new }
sub InitFireshell {
    InitFireshellAlready @ unless
        InitFireshellAlready on
        bye
        0 shellindent !
        256 spaces$ source$ store$
        35 spaces$ baseprefix$ store$
        "" baseprefix$ store$

        0 state !
        0 last !
        0 ip !
        0 w !
        0 loading !

        '$' 16 addbaseprefix
        '#' 10 addbaseprefix
        '%'  2 addbaseprefix

        65536 here - dup 0 > if dup allot endif drop
        ":"       colondef "sub"       postpone endsub
        ";"       colondef "endsub"    postpone endsub  immediate
        "execute" colondef "exec"      postpone endsub
        "'"       colondef "newtick"   postpone endsub
        "["       colondef "state" postpone "off" postpone endsub immediate
        "]"       colondef "state" postpone "on"  postpone endsub
   }

%endif
