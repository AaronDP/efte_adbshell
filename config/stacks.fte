%define(STACKS)

# ---- user/app stacks ----

# structure:   sp size *push *pop *item *items item0 item1 ...
#   * indicate execution vectors: an address, containing an execution token.
#   they can be seen as methods, invoked when a message demands their execution.


sub pop1 {                              # ( a -- x )
   dup @                                # read stack pointer
   dup 7 < will fail                    # would point to stack meta data below stack items
   1 - swap                             # decrement stack pointer
   dup2 ! + @                           # store new stack pointer, add index to stack base, fetch item.
}


sub push1 {                             # ( x a -- )
   dup @2                               # read pointer and size
   over < will fail                     # protect against overflow
   dup2 1 + swap !                      # increment stack pointer. store in meta data
   + !                                  # calc item address and store item.
}

sub item1 {                             # ( n a -- x )
   over 0 < will fail                   # reading below first item
   tuck @ 7 - over < will fail          # reading above last item
   6 + + @                              # read and return item
}

sub items1 { @ 6 - }



# --- new stack class ---
# called stack1 because of single cell items.
# will need double and triple cell items stack, those will be called stack2 resp. stack3, and
# push/pop 2 resp 3 items. for bookmarks - global bookmarks want x, y and file as one single logical item.
# for now single item only, to test the stack creation and action messaging logic.

sub stack1 {                            # create: ( size -- )    run:  ( -- a )
    >r here                             # keep stack size, obtain stack base address (metadata address)
    6 comma                             # initial stack pointer (behind meta data)
    r@ 5 + comma                        # stack size for overflow test: metadata+items-1
    "push1" tick comma                  # execution vector to stack push, "method" like
    "pop1" tick comma                   # execution vector to stack pop, "method" like
    "item1" tick comma                  # execution vector to stack peek, "method" like.
    "items1" tick comma                 # execution vector to stack peek, "method" like.
    r> allot }                          # allocate space for items






# --- stacks with dual items ---
# structure:   sp size *push *pop *item *items item0a item0b item1a item1b ...


sub pop2 {                              # ( a -- x )
   dup @                                # read stack pointer
   dup 7 < will fail                     # would point to stack meta data below stack items
   2 - swap                             # decrement stack pointer
   dup2 ! + @2                          # store new stack pointer, add index to stack base, fetch item.
}


sub push2 {                             # ( x a -- )
   dup @2                               # read pointer and size
   over < will fail                      # protect against overflow
   dup2 2 + swap !                      # increment stack pointer. store in meta data
   + !2                                 # calc item address and store item.
}

sub item2 {                             # ( n a -- x )
   over 0 < will fail                    # reading below first item
   >r  dup +                            # get a out of the way and index>offset
   r@ @ 7 - over < will fail             # reading above last item
   6 +  r> + @2                         # read and return item
}

sub items2 { @ 6 - rshift }

sub stack2 {                            # create: ( size -- )    run:  ( -- a )
    lshift >r here                      # calc stack size, obtain stack base address (metadata address)
    6 comma                             # initial stack pointer (behind meta data)
    r@ 5 + comma                        # stack size for overflow test: metadata+items-1
    "push2" tick comma                  # execution vector to stack push, "method" like
    "pop2" tick comma                   # execution vector to stack pop, "method" like
    "item2" tick comma                  # execution vector to stack peek, "method" like.
    "items2" tick comma                 # execution vector to stack peek, "method" like.
    r> allot }                          # allocate space for items




# --- stacks with triple items ---
# structure:   sp size *push *pop *item *items item0a item0b item0c item1a item1b item1c ...

sub @3 { 3 scrape }                     #  ( a -- x1 x2 x3 )
sub !3 { 3 spread }                     # ( x1 x2 x3 a -- )

sub pop3 {                              # ( a -- x )
   dup @                                # read stack pointer
   dup 7 < will fail                     # would point to stack meta data below stack items
   3 - swap                             # decrement stack pointer
   dup2 ! + @3                          # store new stack pointer, add index to stack base, fetch item.
}


sub push3 {                             # ( x a -- )
   dup @2                               # read pointer and size
   over < will fail                      # protect against overflow
   dup2 3 + swap !                      # increment stack pointer. store in meta data
   + !3                                 # calc item address and store item.
}

sub item3 {                             # ( n a -- x )
   over 0 < will fail                    # reading below first item
   >r  3 *                              # get a out of the way and index>offset
   r@ @ 7 - over < will fail             # reading above last item
   6 +  r> + @3                         # read and return item
}

sub items3 { @ 6 - 3 / }

sub stack3 {                            # create: ( size -- )    run:  ( -- a )
    3 * >r here                         # keep stack size, obtain stack base address (metadata address)
    6 comma                             # initial stack pointer (behind meta data)
    r@ 5 + comma                        # stack size for overflow test: metadata+items-1
    "push3" tick comma                  # execution vector to stack push, "method" like
    "pop3" tick comma                   # execution vector to stack pop, "method" like
    "item3" tick comma                  # execution vector to stack peek, "method" like.
    "items3" tick comma                 # execution vector to stack peek, "method" like.
    r> allot }                          # allocate space for items






# --- stack type independent ---
sub push  { dup 2 + @ execute }         # "message" executes push vector from stack meta data
sub pop   { dup 3 + @ execute }         # "message" executes pop  vector from stack meta data
sub item  { dup 4 + @ execute }         # returns an indexed stack item
sub items { dup 5 + @ execute }         # returns number of items on stack.



# example of use:
# define a new stack:
#      sub foo  { stack1 new }
# execute at init time, to set stack size and allocate stack space:
#      sub InitWhatever   { ... (other init)    8 foo     ... (more init)  }
# push to stack:
#      n foo push
# pop from stack:
#      foo pop
# stack depth:
#      foo items
# stack peek:
#      n foo item


