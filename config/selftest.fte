# -----------------------------------------------------------------------
# eFTE self test script
# This file has been automatically generated by the eFTE packaging tools.
# Manual changes to this file will very likely be lost, and may have an
# adverse effect on eFTE self testing capabilities.
# Copyright (c) 2008 eFTE Group
# -----------------------------------------------------------------------

sub dot33 {                    # ( n -- ) print as nnn:nnn
   lesshash                    
   bl hold
   3:hash
   58 hold
   3:hash
   hashmoretype
}

sub dot9r { 9 dotr }      # ( n -- ) space padded right aligned 9 chars signed number out

sub pass   {
   tor dup2 equals if          "PASS" type$
   else                        "FAIL" type$
   endif 
   rfrom 
   " test " type$ dot33
   "wants"  type$  dot9r
   ", got"  type$  dot9r
   cr
}

sub accumulate { 10 * + }
sub emptyall  { depth$ times drop$    depth times drop }

# 1 - components/alwayspass
sub test_1_1 { 222 222  1001 pass depth depth$ or 0 1001 pass emptyall } # just two passing tests to test test and test that pass will pass
sub test_1_2 { 222 dup  1002 pass depth depth$ or 0 1002 pass emptyall }
sub test_1_3 { test_1_1 test_1_2 }


# 2 - components/between
sub test_2_1 { 10 8 12 between true  2001 pass depth depth$ or 0 2001 pass emptyall }
sub test_2_2 { 8 8 12 between true  2002 pass depth depth$ or 0 2002 pass emptyall }
sub test_2_3 { 12 8 12 between true  2003 pass depth depth$ or 0 2003 pass emptyall }
 
sub test_2_4 { 5 8 12 between false  2004 pass depth depth$ or 0 2004 pass emptyall }
sub test_2_5 { 15 8 12 between false  2005 pass depth depth$ or 0 2005 pass emptyall }
 
sub test_2_6 { -5 -10 0 between true  2006 pass depth depth$ or 0 2006 pass emptyall }
sub test_2_7 { -15 -10 0 between false  2007 pass depth depth$ or 0 2007 pass emptyall }
sub test_2_8 { 10 -20 -10 between false  2008 pass depth depth$ or 0 2008 pass emptyall }
 
sub test_2_9 { test_2_1 test_2_2 test_2_3 test_2_4 test_2_5 test_2_6 test_2_7 test_2_8 }


# 3 - components/bits
sub test_3_1 { 2 invert -3  3001 pass depth depth$ or 0 3001 pass emptyall } # test invert
sub test_3_2 { -5 invert 4  3002 pass depth depth$ or 0 3002 pass emptyall }
 
sub test_3_3 { 0 not true  3003 pass depth depth$ or 0 3003 pass emptyall } # test not
sub test_3_4 { 1234 not false  3004 pass depth depth$ or 0 3004 pass emptyall }
sub test_3_5 { -321 not false  3005 pass depth depth$ or 0 3005 pass emptyall }
sub test_3_6 { true not false  3006 pass depth depth$ or 0 3006 pass emptyall }
sub test_3_7 { false not true  3007 pass depth depth$ or 0 3007 pass emptyall }
 
sub test_3_8 { test_3_1 test_3_2 test_3_3 test_3_4 test_3_5 test_3_6 test_3_7 }


# 4 - components/constants
 # tests:
 # minus, plus,
 # primitives defined constants
 
sub test_4_1 { 20 15 - 5  4001 pass depth depth$ or 0 4001 pass emptyall }
sub test_4_2 { 20 15 + 35  4002 pass depth depth$ or 0 4002 pass emptyall }
sub test_4_3 { 0 false or 1 + true + 0  4003 pass depth depth$ or 0 4003 pass emptyall }
sub test_4_4 { 0 false + 1 - true * 1  4004 pass depth depth$ or 0 4004 pass emptyall }
sub test_4_5 { test_4_1 test_4_2 test_4_3 test_4_4 }


# 5 - components/doloop
sub test_5_1 { 0 101 0 do i + loop 5050  5001 pass depth depth$ or 0 5001 pass emptyall }
sub test_5_2 { 0 200 100 do i + i 150 equals if leave endif inc loop lshift 12850  5002 pass depth depth$ or 0 5002 pass emptyall }
sub test_5_3 { test_5_1 test_5_2 }


# 6 - components/exit
sub test_6_1 { 333 exit lshift } # tests exit
sub test_6_2 { test_6_1 inc 334  6002 pass depth depth$ or 0 6002 pass emptyall }


# 7 - components/iftelsethen
sub test_7_1 { 5 inc true if lshift inc else drop 0 endif lshift 26  7001 pass depth depth$ or 0 7001 pass emptyall }
sub test_7_2 { 3 inc false if drop 0 else inc lshift endif inc 11  7002 pass depth depth$ or 0 7002 pass emptyall }
sub test_7_3 { test_7_1 test_7_2 }


# 8 - components/incdecnegate
sub test_8_1 { 30 inc inc inc 33  8001 pass depth depth$ or 0 8001 pass emptyall }
sub test_8_2 { -2 inc inc inc inc inc 3  8002 pass depth depth$ or 0 8002 pass emptyall }
sub test_8_3 { 20 dec dec 18  8003 pass depth depth$ or 0 8003 pass emptyall }
sub test_8_4 { 1 dec dec dec dec -3  8004 pass depth depth$ or 0 8004 pass emptyall }
sub test_8_5 { 12 negate -12  8005 pass depth depth$ or 0 8005 pass emptyall }
sub test_8_6 { -15 negate 15  8006 pass depth depth$ or 0 8006 pass emptyall }
sub test_8_7 { -8 abs 8  8007 pass depth depth$ or 0 8007 pass emptyall }
sub test_8_8 { 5 abs 5  8008 pass depth depth$ or 0 8008 pass emptyall }
sub test_8_9 { test_8_1 test_8_2 test_8_3 test_8_4 test_8_5 test_8_6 test_8_7 test_8_8 }
 


# 9 - components/lshift
sub test_9_1 { 4 lshift 8  9001 pass depth depth$ or 0 9001 pass emptyall } # test lshift
sub test_9_2 { -4 lshift -8  9002 pass depth depth$ or 0 9002 pass emptyall }
sub test_9_3 { test_9_1 test_9_2 }


# 10 - components/memory
sub test_10_1 { here 5 allot here - -5  10001 pass depth depth$ or 0 10001 pass emptyall }
sub test_10_2 { here dup dup 100 + store here swap  10002 pass depth depth$ or 0 10002 pass emptyall }
sub test_10_3 { here dup 6 1 do i over store inc loop drop
 6 1 do 1 allot loop
 0 6 1 do tor count rfrom + loop nip
 15  10003 pass depth depth$ or 0 10003 pass emptyall }
 
sub test_10_4 { test_10_1 test_10_2 test_10_3 }


# 11 - components/minmax
sub test_11_1 { 2 5 min 2  11001 pass depth depth$ or 0 11001 pass emptyall }
sub test_11_2 { 2 5 max 5  11002 pass depth depth$ or 0 11002 pass emptyall }
sub test_11_3 { -3 -7 min -7  11003 pass depth depth$ or 0 11003 pass emptyall }
sub test_11_4 { -3 -7 max -3  11004 pass depth depth$ or 0 11004 pass emptyall }
 
sub test_11_5 { -2 5 min -2  11005 pass depth depth$ or 0 11005 pass emptyall }
sub test_11_6 { -2 5 max 5  11006 pass depth depth$ or 0 11006 pass emptyall }
sub test_11_7 { 3 -7 min -7  11007 pass depth depth$ or 0 11007 pass emptyall }
sub test_11_8 { 3 -7 max 3  11008 pass depth depth$ or 0 11008 pass emptyall }
 
sub test_11_9 { test_11_1 test_11_2 test_11_3 test_11_4 test_11_5 test_11_6 test_11_7 test_11_8 }


# 12 - components/mod
sub test_12_1 { 20 5 mod 0  12001 pass depth depth$ or 0 12001 pass emptyall }
sub test_12_2 { 15 4 mod 3  12002 pass depth depth$ or 0 12002 pass emptyall }
sub test_12_3 { -18 4 mod -2  12003 pass depth depth$ or 0 12003 pass emptyall }
sub test_12_4 { -24 -7 mod -3  12004 pass depth depth$ or 0 12004 pass emptyall }
sub test_12_5 { test_12_1 test_12_2 test_12_3 test_12_4 }
 


# 13 - components/niptuckpluck
sub test_13_1 { 4 6 8 drop accumulate 64  13001 pass depth depth$ or 0 13001 pass emptyall } # test drop
sub test_13_2 { 3 6 swap accumulate 36  13002 pass depth depth$ or 0 13002 pass emptyall } # test swap
sub test_13_3 { 2 5 over 2:accumulate 252  13003 pass depth depth$ or 0 13003 pass emptyall } # test over
sub test_13_4 { 1 2 3 nip accumulate 31  13004 pass depth depth$ or 0 13004 pass emptyall } # test nip
sub test_13_5 { 4 5 6 minrot 2:accumulate 546  13005 pass depth depth$ or 0 13005 pass emptyall } # test minrot
sub test_13_6 { 7 8 9 tuck 3:accumulate 9897  13006 pass depth depth$ or 0 13006 pass emptyall } # test tuck
sub test_13_7 { 2 4 6 pluck 3:accumulate 2642  13007 pass depth depth$ or 0 13007 pass emptyall } # test pluck
sub test_13_8 { test_13_1 test_13_2 test_13_3 test_13_4 test_13_5 test_13_6 test_13_7 }


# 14 - components/plus
sub test_14_1 { 3 5 + 8  14001 pass depth depth$ or 0 14001 pass emptyall }
sub test_14_2 { -2 9 + 7  14002 pass depth depth$ or 0 14002 pass emptyall }
sub test_14_3 { 6 -8 + -2  14003 pass depth depth$ or 0 14003 pass emptyall }
sub test_14_4 { -11 -7 + -18  14004 pass depth depth$ or 0 14004 pass emptyall }
sub test_14_5 { test_14_1 test_14_2 test_14_3 test_14_4 }


# 15 - components/qdup
sub test_15_1 { 2 0 qdup swap qdup 10 * + 10 * + 220  15001 pass depth depth$ or 0 15001 pass emptyall } # tests qdup


# 16 - components/rfromtor
sub test_16_1 { 5 7 9 tor swap rfrom 2:accumulate 957  16001 pass depth depth$ or 0 16001 pass emptyall }
sub test_16_2 { 2 3 tor 5 rfetch swap rfrom 3:accumulate 3532  16002 pass depth depth$ or 0 16002 pass emptyall }
sub test_16_3 { test_16_1 test_16_2 }


# 17 - components/rshift
sub test_17_1 { 10 dup rshift dup +  17001 pass depth depth$ or 0 17001 pass emptyall } # test rshift
sub test_17_2 { -10 dup rshift dup +  17002 pass depth depth$ or 0 17002 pass emptyall }
sub test_17_3 { test_17_1 test_17_2 }


# 18 - components/strings1
 
 # depth$ - string pushing - len$ - asc/char$ - split$
 
 # see whether depth$ reports correctly
sub test_18_1 { depth$ "ABCD 12345" depth$ drop$ accumulate 10  18001 pass depth depth$ or 0 18001 pass emptyall }
 
 # test push with different string lengths
sub test_18_2 { "ABCD" "12345" "x" "ab" "" depth$ dup times drop$ 5  18002 pass depth depth$ or 0 18002 pass emptyall }
 
 # len$ fails
sub test_18_3 { "" ?len$ 0  18003 pass depth depth$ or 0 18003 pass emptyall }
 
 # test len$
sub test_18_4 { "12345" len$ "abc" len$ "" ?len$ "a" len$ 4:accumulate 1035  18004 pass depth depth$ or 0 18004 pass emptyall }
 
 # test asc / char$
sub test_18_5 { "1" asc inc char$ 3 asc + char$ 2 asc + '7'  18005 pass depth depth$ or 0 18005 pass emptyall }
 
 # split$ tests
sub test_18_6 { "" asc 0  18006 pass depth depth$ or 0 18006 pass emptyall }
sub test_18_7 { "123456" 0 split$ len$ len$ accumulate 6  18007 pass depth depth$ or 0 18007 pass emptyall }
sub test_18_8 { "ABCDEFGH" -100 split$ len$ len$ accumulate 8  18008 pass depth depth$ or 0 18008 pass emptyall }
sub test_18_9 { "1234" 100 split$ len$ len$ accumulate 40  18009 pass depth depth$ or 0 18009 pass emptyall }
sub test_18_10 { "12345678 " 1 split$ asc drop$ '1'  18010 pass depth depth$ or 0 18010 pass emptyall }
sub test_18_11 { "45678" 2 split$ asc drop$ '4'  18011 pass depth depth$ or 0 18011 pass emptyall }
sub test_18_12 { "abcdef" 3 split$ asc drop$ 'a'  18012 pass depth depth$ or 0 18012 pass emptyall }
sub test_18_13 { "12345678" 0 split$ drop$ len$ '1'  18013 pass depth depth$ or 0 18013 pass emptyall }
sub test_18_14 { "12345678" 1 split$ drop$ asc '2'  18014 pass depth depth$ or 0 18014 pass emptyall }
sub test_18_15 { "45678" 2 split$ drop$ asc '6'  18015 pass depth depth$ or 0 18015 pass emptyall }
sub test_18_16 { "abcdef" 3 split$ drop$ asc 'd'  18016 pass depth depth$ or 0 18016 pass emptyall }
 
 
sub test_18_17 { test_18_1 test_18_2 test_18_3 test_18_4 test_18_5 test_18_6 test_18_7 test_18_8
 test_18_9 test_18_10 test_18_11 test_18_12 test_18_13 test_18_14 test_18_15 test_18_16}
 


# 19 - components/times
sub test_19_1 { inc }
sub test_19_2 { 0 0 inc lshift lshift lshift times test_19_1 dec dec dec 5  19002 pass depth depth$ or 0 19002 pass emptyall }
sub test_19_3 { test_19_2 }


# 20 - components/whileuntilagain
sub test_20_1 { 50 6 inc begin lshift dec dup2 less if exit endif dec again drop 0 }
sub test_20_2 { test_20_1 + 133  20002 pass depth depth$ or 0 20002 pass emptyall }
sub test_20_3 { 200 3 lshift begin dec lshift dup2 more while dec lshift repeat + 714  20003 pass depth depth$ or 0 20003 pass emptyall }
sub test_20_4 { 100 2 inc begin lshift inc dup2 less until + 227  20004 pass depth depth$ or 0 20004 pass emptyall }
sub test_20_5 { test_20_2 test_20_3 test_20_4 }


sub selftest {
   "selftest started" type$ cr
    test_1_3 test_2_9 test_3_8 test_4_5 test_5_3 test_6_2 test_7_3 test_8_9
    test_9_3 test_10_4 test_11_9 test_12_5 test_13_8 test_14_5 test_15_1 test_16_3
    test_17_3 test_18_17 test_19_3 test_20_5
    depth depth$ or 0 999999 pass
   "selftest finished" type$ cr
}
