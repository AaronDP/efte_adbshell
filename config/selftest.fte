#/home/l/efte/selftest/production
# -----------------------------------------------------------------------
# eFTE self test script
# This file has been automatically generated by the eFTE packaging tools.
# Manual changes to this file will very likely be lost, and may have an
# adverse effect on eFTE self testing capabilities.
# Copyright (c) 2008 eFTE Group
# -----------------------------------------------------------------------

sub .33 {                    # ( n -- ) print as nnn:nnn
   <hash                    
   bl hold
   3:hash
   ':' hold
   3:hash
   hash> type$
}

sub accumulate { 10 * + }
sub emptyall  {
   depth$ times drop$
   depth times drop
}

sub emptybuffer {
   movefilestart blockbegin
   movefileend    blockend
   ?blockkill                # fails if buffer empty. force to continue
}

sub testfilename { var$ new }
sub timestarted  { var new }

sub beforealltests {
   timestarted off
   emptybuffer
   256 bl repeat$ testfilename store$           # initialize file name variable to 256 chars
   "selftest started" type$ cr
   microsecs timestarted !
   }


sub afteralltests {
   microsecs
   "selftest finished" type$ cr
   timestarted @ -  "Time elapsed: " type$ . "microsecs" type$ cr
   }


sub pass   {    # ( got wants testnum -- )
   >r
      dup2 equals
      depth depth$ accumulate 03 equals
      >r
      r@ and if "PASS" else "FAIL" endif type$
      r> minrot                                 # stacks: 0=err
   r> " test "    type$       .33
   "wanted" type$  9 .r
   ", got"  type$  9 .r

   3 spaces   
   if "stacks ok, " else "STACKS OFF," endif type$
   3 spaces

   testfilename fetch$ type$ cr
   emptyall
   filesave
}

# -------------------------------------------------------------------------------------------------

# 1 - alwayspass.fte
sub test_1_1 { 222 222  1001 pass } # just two passing tests to test test and test that pass will pass
sub test_1_2 { 222 dup  1002 pass }
sub test_1_3 { test_1_1 test_1_2 }
sub test_1 { "alwayspass.fte" testfilename store$ test_1_3 }

# -------------------------------------------------------------------------------------------------

# 2 - arithmetics/between.fte
sub test_2_1 { 10 8 12 between true  2001 pass }
sub test_2_2 { 8 8 12 between true  2002 pass }
sub test_2_3 { 12 8 12 between true  2003 pass }
 
sub test_2_4 { 5 8 12 between false  2004 pass }
sub test_2_5 { 15 8 12 between false  2005 pass }
 
sub test_2_6 { -5 -10 0 between true  2006 pass }
sub test_2_7 { -15 -10 0 between false  2007 pass }
sub test_2_8 { 10 -20 -10 between false  2008 pass }
 
sub test_2_9 { test_2_1 test_2_2 test_2_3 test_2_4 test_2_5 test_2_6 test_2_7 test_2_8 }
sub test_2 { "arithmetics/between.fte" testfilename store$ test_2_9 }

# -------------------------------------------------------------------------------------------------

# 3 - arithmetics/incdecnegate.fte
sub test_3_1 { 30 inc inc inc 33  3001 pass }
sub test_3_2 { -2 inc inc inc inc inc 3  3002 pass }
sub test_3_3 { 20 dec dec 18  3003 pass }
sub test_3_4 { 1 dec dec dec dec -3  3004 pass }
sub test_3_5 { 12 negate -12  3005 pass }
sub test_3_6 { -15 negate 15  3006 pass }
sub test_3_7 { -8 abs 8  3007 pass }
sub test_3_8 { 5 abs 5  3008 pass }
sub test_3_9 { test_3_1 test_3_2 test_3_3 test_3_4 test_3_5 test_3_6 test_3_7 test_3_8 }
sub test_3 { "arithmetics/incdecnegate.fte" testfilename store$ test_3_9 }

# -------------------------------------------------------------------------------------------------

# 4 - arithmetics/minmax.fte
sub test_4_1 { 2 5 min 2  4001 pass }
sub test_4_2 { 2 5 max 5  4002 pass }
sub test_4_3 { -3 -7 min -7  4003 pass }
sub test_4_4 { -3 -7 max -3  4004 pass }
 
sub test_4_5 { -2 5 min -2  4005 pass }
sub test_4_6 { -2 5 max 5  4006 pass }
sub test_4_7 { 3 -7 min -7  4007 pass }
sub test_4_8 { 3 -7 max 3  4008 pass }
 
sub test_4_9 { test_4_1 test_4_2 test_4_3 test_4_4 test_4_5 test_4_6 test_4_7 test_4_8 }
sub test_4 { "arithmetics/minmax.fte" testfilename store$ test_4_9 }

# -------------------------------------------------------------------------------------------------

# 5 - arithmetics/mod.fte
sub test_5_1 { 20 5 mod 0  5001 pass }
sub test_5_2 { 15 4 mod 3  5002 pass }
sub test_5_3 { -18 4 mod -2  5003 pass }
sub test_5_4 { -24 -7 mod -3  5004 pass }
sub test_5_5 { test_5_1 test_5_2 test_5_3 test_5_4 }
sub test_5 { "arithmetics/mod.fte" testfilename store$ test_5_5 }

# -------------------------------------------------------------------------------------------------

# 6 - arithmetics/plus.fte
sub test_6_1 { 3 5 + 8  6001 pass }
sub test_6_2 { -2 9 + 7  6002 pass }
sub test_6_3 { 6 -8 + -2  6003 pass }
sub test_6_4 { -11 -7 + -18  6004 pass }
sub test_6_5 { test_6_1 test_6_2 test_6_3 test_6_4 }
sub test_6 { "arithmetics/plus.fte" testfilename store$ test_6_5 }

# -------------------------------------------------------------------------------------------------

# 7 - bits/bits.fte
sub test_7_1 { 2 invert -3  7001 pass } # test invert
sub test_7_2 { -5 invert 4  7002 pass }
 
sub test_7_3 { 0 not true  7003 pass } # test not
sub test_7_4 { 1234 not false  7004 pass }
sub test_7_5 { -321 not false  7005 pass }
sub test_7_6 { true not false  7006 pass }
sub test_7_7 { false not true  7007 pass }
 
sub test_7_8 { test_7_1 test_7_2 test_7_3 test_7_4 test_7_5 test_7_6 test_7_7 }
sub test_7 { "bits/bits.fte" testfilename store$ test_7_8 }

# -------------------------------------------------------------------------------------------------

# 8 - bits/lshift.fte
sub test_8_1 { 4 lshift 8  8001 pass } # test lshift
sub test_8_2 { -4 lshift -8  8002 pass }
sub test_8_3 { test_8_1 test_8_2 }
sub test_8 { "bits/lshift.fte" testfilename store$ test_8_3 }

# -------------------------------------------------------------------------------------------------

# 9 - bits/rshift.fte
sub test_9_1 { 10 dup rshift dup +  9001 pass } # test rshift
sub test_9_2 { -10 dup rshift dup +  9002 pass }
sub test_9_3 { test_9_1 test_9_2 }
sub test_9 { "bits/rshift.fte" testfilename store$ test_9_3 }

# -------------------------------------------------------------------------------------------------

# 10 - constants.fte
 # tests:
 # minus, plus,
 # primitives defined constants
 
sub test_10_1 { 20 15 - 5  10001 pass }
sub test_10_2 { 20 15 + 35  10002 pass }
sub test_10_3 { 0 false or 1 + true + 0  10003 pass }
sub test_10_4 { 0 false + 1 - true * 1  10004 pass }
sub test_10_5 { test_10_1 test_10_2 test_10_3 test_10_4 }
sub test_10 { "constants.fte" testfilename store$ test_10_5 }

# -------------------------------------------------------------------------------------------------

# 11 - flowcontrol/doloop.fte
sub test_11_1 { 0 101 0 do i + loop 5050  11001 pass }
sub test_11_2 { 0 200 100 do i + i 150 equals if leave endif inc loop lshift 12850  11002 pass }
sub test_11_3 { 10 20 20 do inc inc inc loop dec 9  11003 pass }
sub test_11_4 { 20 0 0 do dec dec dec loop inc 21  11004 pass }
 
sub test_11_5 { 0 20 10 do i + 3 +loop 58  11005 pass }
sub test_11_6 { 0 -20 -10 do i + 3 -loop -58  11006 pass }
sub test_11_7 { 0 -20 -10 do i + -3 +loop -58  11007 pass }
 
sub test_11_8 { 0 20 10 do i + 2 +loop 70  11008 pass }
sub test_11_9 { 0 -20 -10 do i + 2 -loop -70  11009 pass }
sub test_11_10 { 0 -20 -10 do i + -2 +loop -90  11010 pass }
 
sub test_11_11 { 1 5 1 do 4 1 do i * j + loop loop 4396  11011 pass }
 
sub test_11_12 { test_11_1 test_11_2 test_11_3 test_11_4 test_11_5
 test_11_6 test_11_7 test_11_8 test_11_9 test_11_10
 test_11_11 }
sub test_11 { "flowcontrol/doloop.fte" testfilename store$ test_11_12 }

# -------------------------------------------------------------------------------------------------

# 12 - flowcontrol/exit.fte
sub test_12_1 { 333 exit lshift } # tests exit
sub test_12_2 { test_12_1 inc 334  12002 pass }
sub test_12 { "flowcontrol/exit.fte" testfilename store$ test_12_2 }

# -------------------------------------------------------------------------------------------------

# 13 - flowcontrol/iftelsethen.fte
sub test_13_1 { 5 inc true if lshift inc else drop 0 endif lshift 26  13001 pass }
sub test_13_2 { 3 inc false if drop 0 else inc lshift endif inc 11  13002 pass }
sub test_13_3 { test_13_1 test_13_2 }
sub test_13 { "flowcontrol/iftelsethen.fte" testfilename store$ test_13_3 }

# -------------------------------------------------------------------------------------------------

# 14 - flowcontrol/times.fte
sub test_14_1 { inc }
sub test_14_2 { 0 0 inc lshift lshift lshift times test_14_1 dec dec dec 5  14002 pass }
sub test_14_3 { 5 0 times test_14_1 dec 4  14003 pass }
sub test_14_4 { test_14_2 test_14_3 }
sub test_14 { "flowcontrol/times.fte" testfilename store$ test_14_4 }

# -------------------------------------------------------------------------------------------------

# 15 - flowcontrol/whileuntilagain.fte
sub test_15_1 { 50 6 inc begin lshift dec dup2 < if exit endif dec again drop 0 }
sub test_15_2 { test_15_1 + 133  15002 pass }
sub test_15_3 { 200 3 lshift begin dec lshift dup2 > while dec lshift repeat + 714  15003 pass }
sub test_15_4 { 100 2 inc begin lshift inc dup2 < until + 227  15004 pass }
sub test_15_5 { test_15_2 test_15_3 test_15_4 }
sub test_15 { "flowcontrol/whileuntilagain.fte" testfilename store$ test_15_5 }

# -------------------------------------------------------------------------------------------------

# 16 - memory.fte
sub test_16_1 { here 5 allot here - -5  16001 pass }
sub test_16_2 { here dup dup 100 + ! here swap  16002 pass }
sub test_16_3 { here dup 6 1 do i over ! inc loop drop
 6 1 do 1 allot loop
 0 6 1 do >r count r> + loop nip
 15  16003 pass }
 
sub test_16_4 { test_16_1 test_16_2 test_16_3 }
sub test_16 { "memory.fte" testfilename store$ test_16_4 }

# -------------------------------------------------------------------------------------------------

# 17 - stack/niptuckpluck.fte
sub test_17_1 { 4 6 8 drop accumulate 64  17001 pass } # test drop
sub test_17_2 { 3 6 swap accumulate 36  17002 pass } # test swap
sub test_17_3 { 2 5 over 2:accumulate 252  17003 pass } # test over
sub test_17_4 { 1 2 3 nip accumulate 31  17004 pass } # test nip
sub test_17_5 { 4 5 6 minrot 2:accumulate 546  17005 pass } # test minrot
sub test_17_6 { 7 8 9 tuck 3:accumulate 9897  17006 pass } # test tuck
sub test_17_7 { 2 4 6 pluck 3:accumulate 2642  17007 pass } # test pluck
sub test_17_8 { test_17_1 test_17_2 test_17_3 test_17_4 test_17_5 test_17_6 test_17_7 }
sub test_17 { "stack/niptuckpluck.fte" testfilename store$ test_17_8 }

# -------------------------------------------------------------------------------------------------

# 18 - stack/qdup.fte
sub test_18_1 { 2 0 qdup swap qdup 10 * + 10 * + 220  18001 pass } # tests qdup
sub test_18 { "stack/qdup.fte" testfilename store$ test_18_1 }

# -------------------------------------------------------------------------------------------------

# 19 - stack/rfromtor.fte
sub test_19_1 { 5 7 9 >r swap r> 2:accumulate 957  19001 pass }
sub test_19_2 { 2 3 >r 5 r@ swap r> 3:accumulate 3532  19002 pass }
sub test_19_3 { test_19_1 test_19_2 }
sub test_19 { "stack/rfromtor.fte" testfilename store$ test_19_3 }

# -------------------------------------------------------------------------------------------------

# 20 - strings/strings0.fte
 # swap$ dup$ drop$ rot$ over$
sub test_20_1 { "xyz" "987" swap$
 "xyz" equals$
 "987" equals$ and
 true  20001 pass }
 
sub test_20_2 { "abc" "def" over$
 depth$ 3 equals
 "abc" equals$ and
 "def" equals$ and
 "abc" equals$ and
 true  20002 pass }
 
sub test_20_3 { "ABC" dup$
 depth$ 2 equals
 equals$ and
 true  20003 pass }
 
sub test_20_4 { "123" "789" "ABC"
 drop$ drop$
 "123" equals$
 true  20004 pass }
 
sub test_20_5 { "123" "789" "ABC" "def"
 drop$ drop$ drop$
 "456" equals$
 false  20005 pass }
 
sub test_20_6 { "abc" "def" "ghi" rot$
 "abc" equals$
 "ghi" equals$ and
 "def" equals$ and true  20006 pass }
 
 
sub test_20_7 { test_20_1 test_20_2 test_20_3 test_20_4 test_20_5 test_20_6 }
sub test_20 { "strings/strings0.fte" testfilename store$ test_20_7 }

# -------------------------------------------------------------------------------------------------

# 21 - strings/strings1.fte
 
 # depth$ - string pushing - len$ - asc/char$ - split$
 
 # see whether depth$ reports correctly
sub test_21_1 { depth$ "ABCD 12345" depth$ drop$ accumulate 10  21001 pass }
 
 # test push with different string lengths
sub test_21_2 { "ABCD" "12345" "x" "ab" "" depth$ dup times drop$ 5  21002 pass }
 
sub test_21_3 { "" len$ 0  21003 pass }
 
 # test len$
sub test_21_4 { "12345" len$ "abc" len$ "" len$ "a" len$ 3:accumulate 1035  21004 pass }
 
 # test asc / char$
sub test_21_5 { "1" asc inc char$ 3 asc + char$ 2 asc + '7'  21005 pass }
 
 # split$ tests
sub test_21_6 { "" asc 0  21006 pass }
sub test_21_7 { "123456" 0 split$ len$ len$ accumulate 60  21007 pass }
sub test_21_8 { "ABCDEFGH" -100 split$ len$ len$ accumulate 80  21008 pass }
sub test_21_9 { "1234" 100 split$ len$ len$ accumulate 4  21009 pass }
sub test_21_10 { "12345678 " 1 split$ asc drop$ '1'  21010 pass }
sub test_21_11 { "45678" 2 split$ asc drop$ '4'  21011 pass }
sub test_21_12 { "abcdef" 3 split$ asc drop$ 'a'  21012 pass }
sub test_21_13 { "12345678" 0 split$ drop$ len$ '1'  21013 pass }
sub test_21_14 { "12345678" 1 split$ drop$ asc '2'  21014 pass }
sub test_21_15 { "45678" 2 split$ drop$ asc '6'  21015 pass }
sub test_21_16 { "abcdef" 3 split$ drop$ asc 'd'  21016 pass }
 
 
sub test_21_17 { test_21_1 test_21_2 test_21_3 test_21_4 test_21_5 test_21_6 test_21_7 test_21_8
 test_21_9 test_21_10 test_21_11 test_21_12 test_21_13 test_21_14 test_21_15 test_21_16}
sub test_21 { "strings/strings1.fte" testfilename store$ test_21_17 }

# -------------------------------------------------------------------------------------------------

# 22 - strings/strings1a.fte
 
 # depth$ - string pushing - len$ - asc/char$ - cut$
 
 # see whether depth$ reports correctly
sub test_22_1 { depth$ "ABCD 12345" depth$ drop$ accumulate 10  22001 pass }
 
 # test push with different string lengths
sub test_22_2 { "ABCD" "12345" "x" "ab" "" depth$ dup times drop$ 5  22002 pass }
 
sub test_22_3 { "" len$ 0  22003 pass }
 
 # test len$
sub test_22_4 { "12345" len$ "abc" len$ "" len$ "a" len$ 3:accumulate 1035  22004 pass }
 
 # test asc / char$
sub test_22_5 { "1" asc inc char$ 3 asc + char$ 2 asc + '7'  22005 pass }
 
 # cut$ tests
sub test_22_6 { "" asc 0  22006 pass }
sub test_22_7 { "123456" 0 cut$ len$ len$ accumulate 60  22007 pass }
sub test_22_8 { "ABCDEFGH" -100 cut$ len$ len$ accumulate 80  22008 pass }
sub test_22_9 { "1234" 100 cut$ len$ len$ accumulate 4  22009 pass }
sub test_22_10 { "12345678 " 1 cut$ asc drop$ '1'  22010 pass }
sub test_22_11 { "45678" 2 cut$ asc drop$ '4'  22011 pass }
sub test_22_12 { "abcdef" 3 cut$ asc drop$ 'a'  22012 pass }
sub test_22_13 { "12345678" 0 cut$ drop$ len$ '1'  22013 pass }
sub test_22_14 { "12345678" 1 cut$ drop$ asc '2'  22014 pass }
sub test_22_15 { "45678" 2 cut$ drop$ asc '6'  22015 pass }
sub test_22_16 { "abcdef" 3 cut$ drop$ asc 'd'  22016 pass }
 
 
sub test_22_17 { test_22_1 test_22_2 test_22_3 test_22_4 test_22_5 test_22_6 test_22_7 test_22_8
 test_22_9 test_22_10 test_22_11 test_22_12 test_22_13 test_22_14 test_22_15 test_22_16}
sub test_22 { "strings/strings1a.fte" testfilename store$ test_22_17 }

# -------------------------------------------------------------------------------------------------

# 23 - strings/strings2.fte
 # equal$ mid$
 
 
 # equal$ ( needed for next tests )
sub test_23_1 { "a" "a" equals$ true  23001 pass }
sub test_23_2 { "B" 'A' inc char$ equals$ true  23002 pass }
sub test_23_3 { "A" 'B' inc char$ equals$ false  23003 pass }
 
 # mid$
 # interesting case. return "ABC" or "ABCDE"? trying both
sub test_23_4 { "ABCDEFG" -2 5 mid$ "ABC" equals$ true  23004 pass }
sub test_23_5 { "ABCDEFG" -2 5 mid$ "ABCDE" equals$ true  23005 pass }
 
sub test_23_6 { "abcdefgh" 0 2 mid$ "ab" equals$ true  23006 pass }
sub test_23_7 { "123456" 1 3 mid$ "234" equals$ true  23007 pass }
sub test_23_8 { "ABCDEF" 4 6 mid$ "EF" equals$ true  23008 pass }
 
 #{ "abcde" 10 10 mid$ "" equals$ true  23008 pass }
sub test_23_9 { false false not  23009 pass } # just an attention drawer for the line above - terminates efte.
 
 # negative len not tested yet
 
 
sub test_23_10 { test_23_1 test_23_2 test_23_3 test_23_4 test_23_5 test_23_6 test_23_7 test_23_8 test_23_9 }
sub test_23 { "strings/strings2.fte" testfilename store$ test_23_10 }

# -------------------------------------------------------------------------------------------------

# 24 - strings/strings3.fte
 # split$ append$
 
sub test_24_1 { "abcdefgh" 3 split$ "abc" equals$ "defgh" equals$ and true  24001 pass }
sub test_24_2 { "1234" 0 split$ "" equals$ "1234" equals$ and true  24002 pass }
sub test_24_3 { "ABCDE" 10 split$ "ABCDE" equals$ "" equals$ and true  24003 pass }
sub test_24_4 { "" 0 split$ "" equals$ "" equals$ and true  24004 pass }
sub test_24_5 { "" 5 split$ "" equals$ "" equals$ and true  24005 pass }
sub test_24_6 { "" -2 split$ "" equals$ "" equals$ and true  24006 pass }
 
sub test_24_7 { "123" "abcd" append$ "abcd123" equals$ true  24007 pass }
sub test_24_8 { "456" "" append$ "456" equals$ true  24008 pass }
sub test_24_9 { "" "efg" append$ "efg" equals$ true  24009 pass }
 
sub test_24_10 { test_24_1 test_24_2 test_24_3 test_24_4 test_24_5 test_24_6 test_24_7 test_24_8 }
sub test_24 { "strings/strings3.fte" testfilename store$ test_24_10 }

# -------------------------------------------------------------------------------------------------

# 25 - strings/strings3a.fte
 # cut$ append$
 
sub test_25_1 { "abcdefgh" 3 cut$ "abc" equals$ "defgh" equals$ and true  25001 pass }
sub test_25_2 { "1234" 0 cut$ "" equals$ "1234" equals$ and true  25002 pass }
sub test_25_3 { "ABCDE" 10 cut$ "ABCDE" equals$ "" equals$ and true  25003 pass }
sub test_25_4 { "" 0 cut$ "" equals$ "" equals$ and true  25004 pass }
sub test_25_5 { "" 5 cut$ "" equals$ "" equals$ and true  25005 pass }
sub test_25_6 { "" -2 cut$ "" equals$ "" equals$ and true  25006 pass }
 
sub test_25_7 { "123" "abcd" append$ "abcd123" equals$ true  25007 pass }
sub test_25_8 { "456" "" append$ "456" equals$ true  25008 pass }
sub test_25_9 { "" "efg" append$ "efg" equals$ true  25009 pass }
 
sub test_25_10 { test_25_1 test_25_2 test_25_3 test_25_4 test_25_5 test_25_6 test_25_7 test_25_8 }
sub test_25 { "strings/strings3a.fte" testfilename store$ test_25_10 }

# -------------------------------------------------------------------------------------------------

# 26 - zzz_final.fte
sub test_26_1 { depth depth$ or 0  26001 pass }
sub test_26 { "zzz_final.fte" testfilename store$ test_26_1 }

# -------------------------------------------------------------------------------------------------

sub selftest {
   beforealltests
      test_1    test_2    test_3    test_4    test_5    test_6    test_7    test_8
      test_9    test_10   test_11   test_12   test_13   test_14   test_15   test_16
      test_17   test_18   test_19   test_20   test_21   test_22   test_23   test_24
      test_25   test_26   
   afteralltests
}
