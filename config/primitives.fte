#
# some tools and enhancements for macros.
# this are currently used for testing and toying
# with macros, as result many of the current macros
# assume these to be present, as factored out functionality.
#
# -- constants --
sub zero      { push 0 }
sub false     { push 0 }
sub one       { push 1 }
sub true      { push -1 }                       # "true" represented as all bits sets

# -- stack --
sub qdup      { dup if dup endif }              # duplicate top of stack if <> 0
sub nip       { swap drop }                     # drop second of stack
sub tuck      { swap over }                     # copy top of stack below second of stack
sub minRot    { rot rot }                       # rotate top item below second item
sub dup2      { over over }                     # duplicate top two items
sub drop2     { drop drop }                     # drop top two items
sub swap2     { rot tor rot rfrom }             # swap top two pairs of items

# -- bool, bits, comparison  --
sub invert    { true xor }                      # complement all bits
sub not       { zero equals }                   # logical inversion: 0->true,  x->0
sub leftShift { dup plus }                      # bit shift left once
sub Success   { flag }                          # push command return code
sub failure   { flag not }                      # push inverted command return code
sub more      { swap less }                     # true if nos > tos
sub between   { rot tuck less minrot more or not }
sub capital   { push 65; push 90; between }
sub negative  { zero less }                     # < zero?

# -- arithmetic --
sub inc       { one plus }                      # increment top of stack by one
sub dec       { one minus }                     # decrement top of stack by one
sub negate    { invert inc }                    # change sign
sub abs       { dup negative if negate endif }  # remove sign
sub min       { dup2 more if swap endif drop }
sub max       { dup2 less if swap endif drop }
sub mod       { dup2 div mul minus }            # modulo (remainder) function
sub gcd       { begin tuck mod qdup not until } # greatest common denominator

# -- i/o --
sub bl        { push 32 }
sub emit      { insertstring $toschar }
sub Space     { bl emit }                       # print a space character
sub Spaces    { times space }                   # don't have loops yet
sub cr        { linenew }                       # carriage return
sub ok        { insertstring " ok "; cr }       # meant to be used as prompt
sub dot       { insertstring $tos; space }      # output top stack item as number
sub key       { getchar; }                      # wait for key, place its ascii on stack
#sub count    { inc dup dec fetch }
#sub Type     { Zero; Do; Count; Emit; Loop; Drop } # string output

# -- cursor --
sub cursorhome { movelinestart }
sub cursorend  { movelineend }


# need:
#  Allocate
#  Fetch
#  Store
#  Emit
#  some way to print to status bar, or hook up a macro for executing when status bar is updated.


