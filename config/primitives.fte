# primitives.fte
#
# Copyright (c) 2008, eFTE SF Group (see AUTHORS file)
#
# You may distribute under the terms of either the GNU General Public
# License or the Artistic License, as specified in the README file.
#
# some tools and enhancements for macros.
# this are currently used for testing and toying
# with macros, as result many of the current macros
# assume these to be present, as factored out functionality.
#

# -- constants --
sub false     { 0 }
sub true      { -1 }                            # "true" represented as all bits sets
sub cell      { 1 }                             # memory increments per integer
sub cellplus  { 1 + }
sub cellminus { 1 - }
sub cells     { }


# -- stack --
sub qdup      { dup if dup endif }              # duplicate top of stack if <> 0
sub nip       { swap drop }                     # drop second of stack
sub tuck      { swap over }                     # copy top of stack below second of stack
sub pluck     { tor over rfrom swap }           # copy 3rd item to top
sub minrot    { 2:rot }                         # rotate top item below second item
sub dup2      { 2:over }                        # duplicate top two items
sub drop2     { 2:drop }                        # drop top two items
sub swap2     { rot tor rot rfrom }             # swap top two pairs of items

# -- bool, bits, comparison  --
sub invert    { -1 xor }                        # complement all bits
sub not       { 0 equals }                      # logical inversion: 0->true,  x->0
sub lshift    { 1 shift }                       # bit shift left once
sub rshift    { -1 shift }                      # bit shift right once
sub success   { flag }                          # push command return code
sub failure   { flag not }                      # push inverted command return code
sub more      { swap less }                     # true if nos > tos
sub between   { rot tuck less minrot more or not }

sub capital   { 65 90  between }
sub lowercase { 97 122 between }
sub capitalize { dup lowercase if 32 - endif }
sub negative  { 0 less }                        # < zero?

# -- arithmetic --
sub inc       { 1 + }                        # increment top of stack by one
sub dec       { 1 - }                       # decrement top of stack by one
sub negate    { invert inc }                    # change sign
sub abs       { dup negative if negate endif }  # remove sign
sub min       { dup2 more if swap endif drop }
sub max       { dup2 less if swap endif drop }
sub mod       { dup2 / * - }            # modulo (remainder) function
sub gcd       { begin tuck mod qdup not until } # greatest common denominator
sub sqrt      { 0 tuck do inc dup lshift inc plusloop }
sub range     { over + swap }                # start n -> limit start conversion for DO LOOP

# -- cursor --
sub cursorhome { movelinestart }
sub cursorend  { movelineend }



sub count     { inc dup dec fetch }



# need:
#  test block marked?
#  0 split$ no fail


# =============================================================================
#    memory
# =============================================================================

sub free      { memend here - }
sub plusstore { dup tor fetch + rfrom store } # ( x a -- )  adds x to contents of address a
sub comma     { here cell allot store }          # ( x -- )    allocate 1 location, initialized to x
                                                 # can then use vars like:      sub bar { var new }
                                                 #                foo fetch   bar store
sub exchange  { dup fetch tor store rfrom }      # ( x1 a -- x2 )
sub link      { here swap exchange comma }       # ( a -- )


sub var       { here dup cell allot }            # for the new construct:       sub foo { var new }




# =============================================================================
#    strings
# =============================================================================

# thinking of
#  or$:  copy chars from string two into spaces of string 1
#  and$: replace chars in string one against space, if string2 has space on that pos
# example:
# string1:  "xxx    xxx"
# string2:  "1 345678 0"
# or$:      "xxx4567xxx"
# and$:     "x x    x x"
# xor$"     " x 4567 x "


sub nip$      { swap$ drop$ }
sub tuck$     { swap$ over$ }
sub minrot$   { 2:rot$  }
sub dup2$     { 2:over$ }
sub drop2$    { 2:drop$ }
sub equals$   { compare$ not }


sub asc   { dup$ 1 mid$ push $tos$ }            # ( n -- c ) get ascii of nth char in top string
sub char$ { push$ $toschar }                    # ( c -- )   asc on stack becomes char string on stringstack


# -- i/o --
sub key       { getchar }                       # wait for key, place its ascii on stack
sub read      { $Char }                         # read char under cursor
sub emit      { char$ insertstring }
sub type1     { count emit }
sub type      { times type1 drop }              # string output
sub type$     { insertstring }
sub bl        { 32 }
sub space     { 32 emit }                       # print a space character
sub spaces    { times space }
sub cr        { linenew cursorhome }            # carriage return



sub left$     {                                 # ( n -- )
   dup negative if                              # negative n: strip first n chars
      negate len$ over -
   else                                         # positive n: keep first n chars
      0 swap
   endif
   mid$ }

sub right$    {                                 # ( n -- )
  dup negative if                               # negative n: strip last n chars
     0 len$ rot +
  else                                          # positive n: keep last n chars
     dup negate swap
  endif
  mid$ }


sub search$   {                                 # ( n1 -- n2 )
  true swap                                     # search though n1 string stack items,
  0 do                                       # matching against top string. returns
    i inc pick$                                 # item number of matching string as n2,
    over$ equals$                               # or -1
    if drop i leave endif
  loop
  drop$
}



sub slice  { 1 split$ push $tos$ }              # ( -- asc ) cut first char off string and return as ascii
sub splice { char$ swap$ merge$ }               # ( asc -- ) prepend char to string

sub embed$ {                                    # ( asc n -- ) store char at pos n of topmost string, overwriting
   dup dup$ left$                               # cut and keep chars left of write pos
   invert swap$ left$                           # cut and keep chars right of write pos (tricky)
   splice merge$                                # recombine, with char between
}

sub capitalize$ {                               # ( -- )  capitalize all chars of top string
   len$ 0 do                                    # loop though all chars:
      i asc dup lowercase if
         capitalize
         dup i embed$                           #   replace char in string
      endif drop
   loop }


sub repeat$ {                                   # ( c u -- ) create a string of u times char
   ""
   qdup if
      over char$
      dup 1 do
         merge$ dup$
      i plusloop
      swap$ len$ - left$ merge$
   endif
   drop
}


sub spaces$ { bl swap repeat$ }                # ( u -- ) create a string of u spaces


sub minleading$ {                               # ( -- ) remove leading spaces
   len$                                         # assume removing whole string
   dup 0 do                                  # loop through string,
      i asc bl equals not                       # looking for non-space
      if drop i leave endif                     # found, return index to space
   loop
   negate left$                                 # remove leading spaces
}


sub mintrailing$ {                              # ( -- ) remove trailing spaces
   len$
   dup 0 do                                  # loop through sting chars
      dec dup asc                               # select chars, starting with last
      bl equals not if                          # until char not space
         inc leave
      endif
   loop
   left$ }                                      # keep the non-space chars


# test with empty string, and spaces only string
sub trim$ {                                     # ( -- ) remove leading and trailing spaces
   minleading$
   mintrailing$ }          


sub brmovebr$  {                                # ( a n -- )  copy n chars of tos$ to a
   swap dup2 store inc
   swap range do
      slice i store
   loop drop$ }

sub move$    { len$  brmovebr$ }                # ( a -- ) transfers string on string stack to a

sub store$   {                                  # ( a -- ) transfers string on string stack to a
   count                                        # structure size
   2 cells -                           # subtract space for structure size and leading string count
   len$ min                                     # move smaller of this max and string size number of chars.
   brmovebr$ }

sub fetch$    {                                 # ( a -- ) transfers the string at a to string stack.
   cell +
   ""
   count 0 do
      count char$ merge$
   loop drop }

sub var$ { here dup len$ inc dup inc comma allot } # string var description.
# (varsize) (strlen) (char) (char) (char) ...






# --- the number conversion words below respect base, and convert accordingly ---
# we need to init base somewhere - vars are initialized to zero, which is not a good number base.
# using number output without setting base first will result in division by zero
# time for checking out the OnStart: event, which should be ideally suited for one-time init.
sub base      { var new }                        # number base for pic'd num conversion
sub decimal   { 10 base store }
sub hex       { 16 base store }
sub octal     {  8 base store }
sub binary    {  2 base store }


# --- pictured number conversion ---
sub digit     { 48 + dup 57 more if 7 + endif }  # ( u -- asc )
sub slashmod  { dup2 / dup tor * - abs rfrom }                  # ( n1 n2 -- r q )
sub lesshash  { "" } 	    		                      	      		# ( n -- n ) start pictured num conversion
sub hold      { splice }                                                # ( n asc -- n )
sub hash      { base fetch slashmod tor digit splice rfrom }            # ( n1 -- n2 )
sub hashes    { begin hash dup not until }                              # ( n1 -- n2 )
sub hashmoretype { drop type$ }                                         # ( n -- )  end pic num conv and print
sub hashmore  { drop }                                                  # ( n -- )  end pic num conv - should convert
                                                                        # string stack to ( a n ) to comply with standard.
                                                                        # this version leaves converted number on top of string stack
sub sign      { negative if 45 splice endif }                           # ( n -- }
sub brdotbr   { dup tor lesshash hashes rfrom sign hashmore }           # ( n -- )

sub padded  {
   tor len$ -                                                       # ( n c -- ) can't call it "pad" because pad is a
   dup negative not if                                                  #  standard word which does something else
      rfetch swap 0 do dup splice loop
   endif rfrom drop2 }

# --- debugging

sub println { "\n" merge$ print }
sub pout { 1 print }
sub perr { 2 print }
sub poutln { 1 println }
sub perrln { 2 println }

# --- "app" level number output words ---
sub dot       { dup tor
                lesshash
                   bl splice
                   hashes
                   rfrom sign
                hashmoretype }

sub dotr      { tor dup tor                                             # space padded signed number: ( n1 u -- )
                lesshash
                   hashes
                   rfrom sign
                   rfrom bl padded
                hashmoretype }

sub dot0r     { lesshash                                                # zero padded signed number:  ( n1 u -- )
      		    bl splice
                times hash
                hashmoretype }


# --- file editing buffer helpers

# ( -- len )
sub linelen { curline$ len$ }

# ( x y -- )
sub at { movetocolumn movetoline }

# --- initialisation ---
sub OnBoot { decimal }
