# primitives.fte
#
# Copyright (c) 2008, eFTE SF Group (see AUTHORS file)
#
# You may distribute under the terms of either the GNU General Public
# License or the Artistic License, as specified in the README file.
#
# some tools and enhancements for macros.
# this are currently used for testing and toying
# with macros, as result many of the current macros
# assume these to be present, as factored out functionality.
#

# -- constants --
sub zero      { push 0 }
sub false     { push 0 }
sub one       { push 1 }
sub true      { push -1 }                       # "true" represented as all bits sets

# -- stack --
sub qdup      { dup if dup endif }              # duplicate top of stack if <> 0
sub nip       { swap drop }                     # drop second of stack
sub tuck      { swap over }                     # copy top of stack below second of stack
sub pluck     { tor over rfrom swap }
sub minRot    { 2:rot }                         # rotate top item below second item
sub dup2      { 2:over }                        # duplicate top two items
sub drop2     { 2:drop }                        # drop top two items
sub swap2     { rot tor rot rfrom }             # swap top two pairs of items

# -- bool, bits, comparison  --
sub invert    { true xor }                      # complement all bits
sub not       { zero equals }                   # logical inversion: 0->true,  x->0
sub lshift    { push 1 shift }                  # bit shift left once
sub rshift    { push -1 shift }                 # bit shift right once
sub success   { flag }                          # push command return code
sub failure   { flag not }                      # push inverted command return code
sub more      { swap less }                     # true if nos > tos
sub between   { rot tuck less minrot more or not }
sub capital   { push 'A' 'Z' between }
sub lowercase { push 'a' 'z' between }
sub capitalize { dup lowercase if push 32 minus endif }
sub negative  { zero less }                     # < zero?

# -- arithmetic --
sub inc       { one plus }                      # increment top of stack by one
sub dec       { one minus }                     # decrement top of stack by one
sub negate    { invert inc }                    # change sign
sub abs       { dup negative if negate endif }  # remove sign
sub min       { dup2 more if swap endif drop }
sub max       { dup2 less if swap endif drop }
sub mod       { dup2 div mul minus }            # modulo (remainder) function
sub gcd       { begin tuck mod qdup not until } # greatest common denominator
sub range     { over plus swap }                # start n -> limit start conversion for DO LOOP

# -- i/o --
sub bl        { push 32 }
sub emit      { insertstring $toschar }
sub space     { bl emit }                       # print a space character
sub Spaces    { times space }                   # don't have loops yet
sub cr        { linenew }                       # carriage return
sub ok        { insertstring " ok "; cr }       # meant to be used as prompt
sub dot       { insertstring $tosstr; space }   # output top stack item as number
sub key       { getchar; }                      # wait for key, place its ascii on stack
sub read      { push $Char }                    # read char under cursor

#sub count    { inc dup dec fetch }
#sub type1    { count emit }
#sub type     { times type1 drop } # string output

# -- cursor --
sub cursorhome { movelinestart }
sub cursorend  { movelineend }


#sub sqrt      { zero tuck do inc dup leftshift inc plusloop }
#sub sqrt      { one begin dup2 div over minus one inc  div dup while plus repeat drop nip }
#sub factor    { dup if dup one and
#                if dup sqrt  3:push;
#                   begin dup2 less
#                      if drop2 exit endif
#                      pluck over mod
#                   while inc inc 
#                   repeat nip
#                endif
#             else 2:Push;
#             endif  }
#sub prime     { dup factor equals }


# need:
#  Allocate
#  Fetch
#  Store
    
#  test block marked?
#  stack # chars on line  (or macro: mark pos, CursorEnd, CursorColumn, return to marked pos)

# =============================================================================
# String Stack Helpers
# =============================================================================

sub nip$      { swap$ drop$ }
sub tuck$     { swap$ over$ }
sub minrot$   { 2:rot$  }
sub dup2$     { 2:over$ }
sub drop2$    { 2:drop$ }
sub equals$   { compare$ not }
sub type$     { insertstring $tos$ drop$ }


sub left$     {                                 # ( n -- )
   dup negative if                              # negative n: strip first n chars
      negate len$ over minus
   else                                         # positive n: keep first n chars
      zero swap
   endif
   mid$ }

sub right$    {                                 # ( n -- )
  dup negative if                               # negative n: strip last n chars
     zero len$ rot plus
  else                                          # positive n: keep last n chars
     dup negate swap
  endif
  mid$ }


sub search$   {                                 # ( n1 -- n2 )
  push -1 swap                                  # search though n1 string stack items,
  zero do                                       # matching against top string. returns
    I inc pick$                                 # item number of matching string as n2,
    over$ equals$                               # or -1
    if drop I leave endif
  loop
  drop$
}


sub asc   { dup$ push 1 mid$ push $tos$ }       # ( n -- c ) get ascii of nth char in top string
sub char$ { push$ $toschar }                    # ( c -- )   asc on stack becomes char string on stringstack


#sub embed$ {                                    # ( asc n -- ) store char at pos n of topmost string, overwriting
#   dup split$                                   # can't use split$ for this like this because it bombs on 0 split$
#   push -1 left$
#   char$ swap$ 2:merge$
#}


sub embed$ {                                    # ( asc n -- ) store char at pos n of topmost string, overwriting
   dup         dup$ left$                       # cut and keep chars left of write pos
   inc negate swap$ left$                       # cut and keep chars right of write pos
              char$ swap$                       # put replacement char between
                 2:merge$                       # merge all three strings
}


# probably faster: only embeds if char has actually been changed
sub capitalize$ {                               # ( -- )  capitalize all chars of top string
   len$ zero do                                 # loop though all chars:
      i asc dup lowercase if
         capitalize
         dup i embed$                           #   replace char in string
      endif drop
   loop }







# =============================================================================
#    memory
# =============================================================================

sub cell      { push 1 }
sub plusstore { dup tor fetch plus rfrom store } # ( x a -- )  adds x to contents of address a
sub allot     { here plus zero swap store }
#sub comma    { here store cell allot }
sub comma     { here cell allot store }          # ( x -- )    allocate 1 location, initialized to x
sub free      { memend here minus }


sub zerocomma { zero comma }
sub var       { here zerocomma }                 # for the new construct:       sub foo { var new }
                                                 # can then use vars like:      sub bar { var new }
                                                 #                foo fetch   bar store

### -- not working yet - needs a small mod in "new". also, because of not having a "does" part
###  in the structure description, this may be a better candidate for the envisioned "methods"
# sub array     { here swap times zerocomma }
# sub myarray   { push 16 array new }


sub base      { var new }                        # number base for pic'd num conversion
sub decimal   { push 10 base store }
sub hex       { push 16 base store }
sub octal     { push  9 base store }


