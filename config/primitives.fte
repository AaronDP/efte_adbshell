# primitives.fte
#
# Copyright (c) 2008, eFTE SF Group (see AUTHORS file)
#
# You may distribute under the terms of either the GNU General Public
# License or the Artistic License, as specified in the README file.
#
# some tools and enhancements for macros.
# this are currently used for testing and toying
# with macros, as result many of the current macros
# assume these to be present, as factored out functionality.
#

# can't use this chars in names (yet):   = , # :
# TODO: fix bugs. a few words in here exist to work around known bugs.
#   insertstring:   prompts for string when trying to insert empty stringdd


# -- constants --
sub false     { 0 }
sub true      { -1 }                            # "true" represented as all bits sets
sub cell      { 1 }                             # memory increments per integer
sub cell+     { 1 + }
sub cell-     { 1 - }
sub cells     { }


# -- stack --
sub qdup      { dup for dup }                   # duplicate top of stack if <> 0
sub nip       { swap drop }                     # drop second of stack
sub tuck      { swap over }                     # copy top of stack below second of stack
sub pluck     { >r over r> swap }               # copy 3rd item to top
sub minrot    { 2:rot }                         # rotate top item below second item
sub dup2      { 2:over }                        # duplicate top two items
sub drop2     { 2:drop }                        # drop top two items
sub swap2     { rot >r rot r> }                 # swap top two pairs of items


# -- arithmetic, bool, bits, comparison  --
sub inc       { 1 + }                           # increment top of stack by one
sub dec       { 1 - }                           # decrement top of stack by one
sub invert    { -1 xor }                        # complement all bits
sub negate    { 0 swap - }                      # change sign
sub not       { 0 equals }                      # logical inversion: 0->true,  x->0
sub lshift    { 1 shift }                       # bit shift left by 1
sub rshift    { -1 shift }                      # bit shift right by one
sub <<        { shift }                         
sub >>        { negate shift }
sub success   { flag }                          # push command return code
sub failure   { flag not }                      # push inverted command return code
sub >         { swap < }                        # true if nos > tos
sub between   { rot tuck < minrot > or not }
sub negative  { 0 < }                           # -n
sub positive  { -1 > }                          # 0..n
sub abs       { dup 0 < for negate }            # remove sign
sub min       { dup2 > for swap drop }
sub max       { dup2 < for swap drop }
sub umin      { dup2 xor 0 < if max else min endif }  # ( u1 u2 -- u1|u2 ) unsigned min
sub umax      { dup2 xor 0 < if min else max endif }  # ( u1 u2 -- u1|u2 ) unsigned max
sub mod       { dup2 / * - }                    # modulo (remainder) function
sub gcd       { begin tuck mod qdup not until } # greatest common denominator
sub sqrt      { 0 tuck do inc dup lshift inc +loop }
sub range     { over + swap }                   # start n -> limit start conversion for DO LOOP
sub +!        { dup >r @ +   r> ! }             # ( x a -- )  adds x to contents of address a
sub or!       { dup >r @ or  r> ! }             # ( x a -- )  bitwise  or x into address a
sub and!      { dup >r @ and r> ! }             # ( x a -- )  bitwise and x into address a
sub xor!      { dup >r @ xor r> ! }             # ( x a -- )  bitwise xor x into address a
sub toggle    { true swap xor! }                # ( a -- )  bitwise invert of contents of a

# --- define a variables class
sub var       { here dup cell allot }           # for the new construct:       sub foo { var new }


# --- number conversion words respect base, and convert accordingly
sub decimal   { 10 base ! }
sub hex       { 16 base ! }
sub octal     {  8 base ! }
sub binary    {  2 base ! }



# --- character test
sub bl        { ' ' }
sub capital   { 'A' 'Z' between }
sub lowercase { 'a' 'z' between }
sub capitalize { dup lowercase 32 and - }
sub undercast  { dup capital   32 and + }
sub printable  { bl 127 between }



sub numeric   {             # ( asc -- flag )      converts ascii to numeric value, and flag if legal cipher.
   capitalize '0' -         #                      respects base, and reports only those chars valid which are
   dup 10 16 between or     #                      legal in the resp. base
   dup 16 > 7 and -
   0 base @ dec between }

sub cipher   {              # ( asc -- u -1 | 0 )  converts ascii to numeric value, and flag if legal cipher.
   capitalize '0' -         #                      respects base, and reports only those chars valid which are
   dup 10 16 between or     #                      legal in the resp. base
   dup 16 > 7 and -
   dup 0 base @ dec between
   qdup nip  }


# -- cursor --
sub cursorhome { movelinestart }
sub cursorend  { movelineend }



# need:
#  test block marked?


# =============================================================================
#    memory
# =============================================================================

sub off       { false swap ! }                  # ( a -- )   sets contents of a to false
sub on        { true swap ! }                   # ( a -- )   sets contents of a to true
sub count     { 1 + dup 1 - @ }
sub comma     { here cell allot ! }             # ( x -- )    allocate 1 location, initialized to x
sub exchange  { dup @ >r ! r> }                 # ( x1 a -- x2 )
sub link      { here swap exchange comma }      # ( a -- )
sub free      { memend here - }


sub spread {           # ( x0 x1 x2 ... xn-1 a n -- )  store xn at a+n
   >r 1 - r> 
   range swap do 
      i ! 
   1 -loop }


# =============================================================================
#    strings
# =============================================================================

# thinking of
#  or$:  copy chars from string two into spaces of string 1
#  and$: replace chars in string one against space, if string2 has space on that pos
# example:
# string1:  "xxx    xxx"
# string2:  "1 345678 0"
# or$:      "xxx4567xxx"
# and$:     "x x    x x"
# xor$"     " x 4567 x "


sub nip$      { swap$ drop$ }
sub tuck$     { swap$ over$ }
sub minrot$   { 2:rot$  }
sub dup2$     { 2:over$ }
sub drop2$    { 2:drop$ }
sub equals$   { compare$ not }
sub prepend$  { swap$ append$ }


# TODO: can maybe simplify now after mid$ index fix.
sub cut$ {                                      # ( n -- )  s( $1 -- $2 $3 )  splits string at position n,
   dup if
      dup dup$ len$ + 0 >
      if 
         dup$ dup -1 mid$
         swap$ 0 swap mid$
         exit
      endif
   endif 
   drop ""
}


sub slice     { 1 cut$ asc }                    # ( -- asc ) cut first char off string and return as ascii
sub splice    { char$ prepend$ }                # ( asc -- ) prepend char to string
sub ascn      { dup$ 1 mid$ asc }               # ( n -- c ) get ascii of nth char in top string

# -- i/o --
sub key        { winrefresh getchar }            # wait for key, place its ascii on stack
sub read$      { curchar$ }                      # read char under cursor as string
sub read       { curchar$ asc }                  # read char under cursor as asc
sub cursorchar { curchar$ asc }                  # read char under cursor, convert to asc
sub emit       { typechar }
sub type1      { count emit }
sub type       { times type1 drop }              # string output
#TODO:  insertstring bug when empty string. workaround here.
sub type$      { dup$ len$ if dup$ insertstring endif drop$  }
#TODO: change insertstring to not behave funny when empty string is sent.
#TODO: output words more clearly taking account of mode:
#TODO:    insert insert$            always insert char or string
#TODO:    overtype overtype$        always overtype char or string
#TODO:    emit  type$               depends on overtype/insert mode

# stateful linenew may autoindent - workaround here
sub cr         {
    ?cursordown failure for linenew
    cursorhome killtolineend }


sub left$      {                                # ( n -- )
   dup 0 < if                                   # negative n: strip first n chars
      negate dup$ len$ over -
   else                                         # positive n: keep first n chars
      0 swap
   endif
   mid$ }

sub right$    {                                 # ( n -- )
  dup 0 < if                                    # negative n: strip last n chars
     0 swap
     dup$ len$ +
  else                                          # positive n: keep last n chars
     dup negate swap
  endif
  mid$ }




# unsigned number string to numeric
sub unumber? {                          # ( -- n -1 | 0 )
   -1 0                                 # assume valid number, initial value 0
   dup$ len$ 0 do                       # loop through chars
      base @ *                          #  accu*radix
      i ascn cipher if +                #  next char valid cipher? yes: accumulate
      else
         2:drop 0 0 leave               #  no: signal "not a number" and leave
      endif
   loop
   drop$
   swap qdup drop                       # return result as specified in stack diagram.
}


sub number? {                           # ( -- n -1 | 0 )
   0 ascn '-' equals
   if
      -1 left$
      unumber?
      >r 
      r@ for negate 
      r>
   else
      unumber?
   endif
}




sub search$   {                                 # ( n1 -- n2 )
  true swap                                     # search though n1 string stack items,
  0 do                                          # matching against top string. returns
    i inc pick$                                 # item number of matching string as n2,
    over$ equals$                               # or -1
    if drop i leave endif
  loop
  drop$
}


sub embed$ {                                    # ( asc n -- ) store char at pos n of topmost string, overwriting
   dup dup$ left$                               # cut and keep chars left of write pos
   invert swap$ left$                           # cut and keep chars right of write pos (tricky)
   splice append$                               # recombine, with char between
}

sub capitalize$ {                               # ( -- )  capitalize all chars of top string
   dup$ len$ 0 do                                    # loop though all chars:
      i ascn dup lowercase if
         capitalize
         dup i embed$                           #   replace char in string
      endif drop
   loop }


sub repeat$ {                                   # ( u c -- ) create a string of u times char
   swap ""
   qdup if
      over char$
      dup 1 do
         append$ dup$
      i +loop
      swap$ dup$ len$ - left$ append$
   endif
   drop
}

sub spaces$   { bl repeat$ }                    # ( u -- ) create a string of u spaces
sub spaces    { spaces$ type$ }
sub space     { insertspace }                   # print a space character



sub skip$ {                                     # ( asc -- idx )  search for first char which is not asc.
   -1                                           #                 index or -1 as result (not other than asc)
   dup$ len$ 0 do                               #                 drops string.
      over i ascn xor
      if drop i leave endif
   loop
   drop$ nip
   }


sub scan$ {                                     # ( asc -- idx )  search for first occurance of asc in string
   -1                                           #                 index or -1 as result.
   dup$ len$ 0 do                               #                 drops string.
      over i ascn equals
      if drop i leave endif
   loop
   drop$ nip }


sub split$    {                                 # ( asc -- )      cut string at asc, leaving left part as tos, rest as nos
   dup$ scan$                                   #                 if asc not found, leave whole string as tos, empty string as nos.
   dup 0< if
      drop dup$ len$
   endif
   cut$
#   swap$ -1 left$ swap$                        # remove asc from string remainder
   }

sub diags { diag diag$ }

sub minleading$ {                               # ( asc -- ) remove leading occurances of string
   dup$ skip$                                   # index, or -1 for no leading occurences of asc
   dup 0 < if  drop$ "" else
   dup     if  dup negate left$ endif
   endif drop
}



sub mintrailing$ {                              # ( asc -- ) remove trailing occurences of asc
   0                                            # assume no different chars
   0 dup$ len$ do                               # loop through string chars
      over i 1 - ascn                           # select chars, starting with last
      xor if                                    # until different asc
         drop i leave
      endif
   1 -loop
   left$                                        # keep left part except trailing asc
   drop }                                       



sub parse$ {                                    # ( asc -- )      search for asc in string, keep part left of asc.
   dup minleading$                              #                 skip leading asc first
   dup$ scan$
   dup -1 > if  dup left$  endif                #                 asc not found: return whole string, otherwise cut at asc
   drop }



# test with empty string, and spaces only string
sub trim$ {                                     # ( -- ) remove leading and trailing spaces
   bl minleading$
   bl mintrailing$ }



sub brmovebr$  {                                # ( a n -- )  copy n chars of tos$ to a
   swap dup2 ! inc
   swap range do
      slice i !
   loop drop$ }

sub move$    { dup$ len$  brmovebr$ }           # ( a -- ) transfers string on string stack to a


sub store$   {                                  # ( a -- ) transfers string on string stack to a
   count                                        # structure size
   2 cells -                                    # subtract space for structure size and leading string count
   dup$ len$ min                                # move smaller of this max and string size number of chars.
   brmovebr$
   }


sub combine {
   ""
   0 do                                         # for all chars in string do ...
      count char$ append$                       # get char and add to string
   loop drop }

sub fetch$    {                                 # ( a -- ) transfers the string at a to string stack.
   cell +                                       # skip first cell (containing amount of allocated space to string var)
   count
   combine }

sub var$ { here dup dup$ len$ inc dup inc comma allot } # string var description.

# (varsize) (strlen) (char) (char) (char) ...
#sub var$ {
#   here              diag diag$  "A " 2 print
#   dup$ len$ inc     diag diag$  "B " 2 print
#   dup inc comma     diag diag$  "C " 2 print
#   allot             diag diag$  "D " 2 print
#   dup store$        diag diag$  "E " 2 print
#   }



# --- debugging

sub println { print "\n" print }
sub pout    { 1 print }
sub perr    { 2 print }
sub poutln  { 1 println }
sub perrln  { 2 println }


# --- pictured number conversion ---
sub digit     { dup 10 < 3 xor '4' + + }        # ( u -- asc )
sub /mod      { dup2 / dup >r * - abs r> }      # ( n1 n2 -- r q )
sub <hash     { "" } 	  		                # ( n -- n ) start pictured num conversion with empty string
sub hold      { char$ prepend$ }                # ( n asc -- n )
sub hash      { base @ /mod swap digit hold }   # ( n1 -- n2 )
sub hashes    { begin hash dup not until }      # ( n1 -- n2 )
sub hash>     { drop }                          # ( n -- )  end pic num conv - should convert
                                                # string stack to ( a n ) to comply with standard.
                                                # this version leaves converted number on top of string stack
sub sign      { 0 < if '-' hold endif }         # ( n -- }
sub brdotbr   { dup <hash hashes hash> sign }   # ( n -- )

sub padded  {                                   # ( n c -- )
   >r dup$ len$ -                               # can't call it "pad" because pad is a
   0 max qdup if                                # standard word which does something else
      r@ repeat$ prepend$
   endif r> drop }



# --- "app" level number output words ---
# ( n -- ) signed number output with one trailing space
sub .    { dup >r <hash bl hold  hashes r> sign hash> type$ }

# ( n u -- ) space padded signed number
sub .r { >r dup >r <hash hashes  r> sign  r> bl padded  hash> type$ }

# ( n -- )   zero padded signed number with one trailing space
sub .0r     { <hash  bl hold  times hash  hash> type$ }



# --- file editing buffer helpers
sub linelen    { curline$ dup$ len$ drop$ }     # ( -- len )
sub at         { 1 + movetoline  1 + movetocolumn } # ( x y -- )

sub cursorcol  { at? drop 1 + }                     # ( -- x )  fade out
sub cursorcolumn { at? drop 1 + }                   # ( -- x )
sub cursorrow  { at? nip  1 + }                     # ( -- y )

sub emptybuffer {
   movefilestart blockbegin
   movefileend    blockend
   ?blockkill
}

sub cls        { emptybuffer }                      # wipe current buffer

sub linecount  {                                    # ( -- u ) number of lines in file
   at? movefileend
   cursorrow minrot
   at }


sub blockmove   { blockcut blockpaste }             # move block to cursor

# sub sleep  { winrefresh ms }  # winrefresh doesn't do what i hoped it would


sub @2  { dup @ swap 1 + @ }    # ( a -- x1 x2 ) double fetch, from 2 consecutive addresses
sub !2  { tuck 1 + ! ! }        # ( x1 x2 a -- ) double store, to 2 consecutive addresses



# bookmark slots, numbered  (0..255)
sub BookMark { var new  512 allot }
sub StoreBookmark  { at? rot lshift BookMark + !2 }
sub MoveToBookmark { lshift BookMark +  @2 at }


# global bookmarks: bookmark stack. location 0  is stack pointer. 1 is max size.
sub BookMarkStack { var new  512 allot } 

sub PopBookmark {
   BookMarkStack @ 2 < if
      "bookmarkstack empty" message fail
   else
      -2  BookMarkStack
      dup @ @2 at  +!
   endif }   
      

sub PushBookmark { 
   BookMarkStack @2 < if
      at? 
      BookMarkStack 
      2 over +!  
      @ !2
   else
      "bookmarkstack full" message fail
   endif }   


sub InitBookmarks {
   0 BookMark !
   0 510 BookMarkStack 2 spread
 }



sub comma$  {   # ( -- )     "comma" string to dp
   dup$ len$
   1 + dup comma
   here swap allot
   move$ }




# random access stack of filenames. adding returns token. token converts to filename
sub FileStack { var new 512 allot }

sub AddFile {      # ( -- n )    file name passed as string
   FileStack @ 1 +
   dup FileStack !
   here comma$
   over FileStack + !
   }


sub FileName {     # ( token -- )    places filename on string stack
   fileStack + @ fetch$  }


sub FindFile {    # ( -- 0 | token )  file name as string
   0
   FileStack
   dup @ 0 do
      1 +
      dup$
      dup @ fetch$
      equals$ if
         filestack -
         swap leave
      endif
   loop drop drop$ }


sub File  {   # ( -- n )  given filename as string, adds it to filestack if not already in it. returns file token
   dup$ FindFile
   qdup not if
      dup$ AddFile
   endif
   drop$ }





# --- initialisation ---
sub attempt   { tick execute }                      # execute macro, name given as string, if it exists only
sub OnBoot    {
   decimal
   0 510 FileStack 2 spread
   "InitBookmarks"   attempt
   "InitMySettings"  attempt
   "InitSelftest"    attempt
   "InitInterpreter" attempt
   }

